<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: beam.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: beam.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 *
 * Summary.
 * &lt;p>Light Beam Studies.&lt;/p>
 *
 * @author Claudio Esperança
 * @author Paulo Roma
 * @since 08/06/2022
 * @see &lt;a href="/cwdc//13-webgl/beam/segments.html">link&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/beam/beam.js">source&lt;/a>
 * @see {@link https://github.com/regl-project/regl github}
 * @see {@link https://regl-project.github.io/regl/ regl: Fast functional WebGL}
 * @see {@link https://vallandingham.me/regl_intro.html An Intro to regl for Data Visualization}
 * @see {@link https://observablehq.com/@spattana/basic-webgl-programming-using-regl Basic WebGL Programming Using REGL}
 * @see {@link https://peterbeshai.com/blog/2017-05-26-beautifully-animate-points-with-webgl-and-regl/ Beautifully Animate Points with WebGL and regl}
 * @see {@link https://drive.google.com/file/d/1bDLGlqdqgMBsUSr1icIaSqdm_5VC2io5/view Vídeo: Animação com feixes}
 * @see {@link http://zach.li Zach Lieberman} {@link https://www.instagram.com/p/Cc3uGxaJ2MB/ (Instagram)}
 */

"use strict";

/**
 * &lt;p>d3 is a collection of modules that are designed to work together.&lt;/p>
 * You can use the modules independently,
 * or you can use them together as part of the default build.
 * @external d3
 * @see https://d3js.org/api
 */

/**
 * An array of eight categorical colors.
 * @function schemeAccent
 * @memberof external:d3
 * @see https://d3js.org/d3-scale-chromatic/categorical#schemeAccent
 * @see https://www.geeksforgeeks.org/d3-js-schemeaccent-method/
 */

/**
 * Edge light object.
 */
class edgeLight {
  /**
   * Constructs a new edge:
   *
   * &lt;ul>
   *  &lt;li> initial random position: [-1,1]x{-1,1]}, &lt;/li>
   *  &lt;li> initial random angle: [0,2π), &lt;/li>
   *  &lt;li> random direction: (cos(angle ± π/2), sin(angle ± π/2)) &lt;/li>
   *  &lt;li> initial size: 0.1&lt;/li>
   *  &lt;li> random maximum size: [0.5, 1.0], &lt;/li>
   *  &lt;li> random color from d3 {@link palette}, &lt;/li>
   *  &lt;li> increment: 0.001 (for growth and rotation). &lt;/li>
   * &lt;/ul>
   *
   * @param {Number} aspect canvas aspect ratio.
   */
  constructor(aspect = 1) {
    this.pos = [(Math.random() * 2 - 1) * aspect, Math.random() * 2 - 1];
    this.angle = (Math.PI / 4) * ~~(Math.random() * 8);
    const turn = this.angle + ((Math.random() &lt; 0.5 ? -1 : 1) * Math.PI) / 2;
    this.direction = [Math.cos(turn), Math.sin(turn)];
    this.size = 0.1;
    this.maxSize = Math.random() / 2 + 0.5;
    this.color = palette[~~(Math.random() * palette.length)];
    this.increment = 0.001;
  }

  /**
   * A property holding this segment origin.
   *
   * @return {Array&lt;Number>} segment origin.
   */
  get a() {
    return [
      this.pos[0] + Math.cos(this.angle) * this.size,
      this.pos[1] + Math.sin(this.angle) * this.size,
    ];
  }

  /**
   * A property holding this segment end point.
   *
   * @return {Array&lt;Number>} segment end point.
   */
  get b() {
    return [
      this.pos[0] - Math.cos(this.angle) * this.size,
      this.pos[1] - Math.sin(this.angle) * this.size,
    ];
  }

  /**
   * A property for signaling the end of life of this segment.
   *
   * @return {Boolean} ending condition.
   */
  get terminated() {
    return this.size &lt; 0;
  }

  /**
   * &lt;p>Animation function.&lt;/p>
   *
   * Grows and rotates this segment by a fixed increment in each frame.
   */
  animate() {
    if (!this.terminated) {
      this.size += this.increment;
      this.pos[0] += this.direction[0] * this.increment;
      this.pos[1] += this.direction[1] * this.increment;
      this.angle += this.increment * Math.PI;
    }
    if (this.size > this.maxSize) this.increment = -this.increment;
  }
}

/**
 * &lt;p>Return a regl object and a draw command with the source code for a vertex and a fragment shader.&lt;/p>
 *
 * A draw command wraps up all of the WebGL state associated with a draw call
 * (either drawArrays or drawElements) and packages it into a single reusable function.
 *
 * @param {HTMLElement} canvas WebGL canvas.
 * @returns {Object&lt;regl:Object, drawEdge:function>} regl object and draw function.
 * @see {@link http://regl.party/api#from-a-canvas regl api}
 */
function edgeRenderProgram(canvas) {
  const regl = createREGL(canvas);

  const drawEdge = regl({
    frag: `
      precision mediump float;
      uniform vec4 color;
      uniform vec2 a;
      uniform vec2 b;
      uniform vec2 resolution;
      uniform float attenuationExponent;
      uniform float lightIntensity;
      uniform float beamLength;

      float orient(vec2 a, vec2 b, vec2 c) {
        return (c.y*b.x - c.x*b.y) + (c.x*a.y - c.y*a.x) + (b.y*a.x - b.x*a.y);
      }

      float orientedSegment( in vec2 p, in vec2 a, in vec2 b ) {
        vec2 pa = p-a, ba = b-a;
        float t = dot(pa,ba)/dot(ba,ba);
        float h = clamp(t , 0.0, 1.0 );
        vec2 u = pa - ba*h;
        if (h == t &amp;&amp; orient(p,a,b) >= 0.) return length( u );
        return 1e20;
      }

      void main () {
        vec2 p = (2.0*gl_FragCoord.xy-resolution)/resolution.y;
        float d = orientedSegment(p, a, b);
        if (d &lt; beamLength) {
          float t = smoothstep(0.,0.005,d)-smoothstep(0.005,0.01,d);
          gl_FragColor = vec4(color.xyz,t+lightIntensity*pow((1.-d/beamLength),attenuationExponent));
        } else discard;
      }`,

    vert: `
      attribute vec2 position;
      void main () {
        gl_Position = vec4(position, 0., 1.);
      }`,

    attributes: {
      position: [
        [-1, -1],
        [1, -1],
        [1, 1],
        [-1, 1],
      ],
    },

    depth: {
      enable: false,
    },

    primitive: "triangle fan",

    blend: {
      enable: true,
      func: {
        srcRGB: "src alpha",
        srcAlpha: 1,
        dstRGB: "one minus src alpha",
        dstAlpha: 1,
      },
      equation: {
        rgb: "add",
        alpha: "add",
      },
      color: [0, 0, 0, 0],
    },

    count: 4,

    uniforms: {
      resolution: [canvas.width, canvas.height],
      a: regl.prop("a"),
      b: regl.prop("b"),
      color: regl.prop("color"),
      attenuationExponent: regl.prop("attenuationExponent"),
      lightIntensity: regl.prop("lightIntensity"),
      beamLength: regl.prop("beamLength"),
    },
  });

  return { regl, drawEdge };
}

/**
 * Array with eight categorical (visually distinct} normalized RGBA colors.
 * &lt;pre>
 *  [
 *    [ 0.4980392156862745, 0.788235294117647,   0.4980392156862745,  1 ], // Iguana Green
 *    [ 0.7450980392156863, 0.6823529411764706,  0.8313725490196079,  1 ], // Wisteria
 *    [ 0.9921568627450981, 0.7529411764705882,  0.5254901960784314,  1 ], // Macaroni And Cheese
 *    [ 1,                  1,                   0.6,                 1 ], // Canary
 *    [ 0.2196078431372549, 0.4235294117647059,  0.6901960784313725,  1 ], // Blue Yonder
 *    [ 0.9411764705882353, 0.00784313725490196, 0.4980392156862745,  1 ], // Mexican Pink
 *    [ 0.7490196078431373, 0.3568627450980392,  0.09019607843137255, 1 ], // Alloy Orange
 *    [ 0.4,                0.4,                 0.4,                 1 ]  // Granite Gray
 *  ]
 * &lt;/pre>
 * @var {Array&lt;Array&lt;Number>>} palette
 * @see {@link external:d3.schemeAccent}
 */
const palette = d3.schemeAccent.map((c) => {
  let color = d3.color(c);
  return [color.r / 255, color.g / 255, color.b / 255, 1];
});

/**
 * &lt;p>Entry point when page is loaded.&lt;/p>
 *
 * @see {@link https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html WebGL Resizing the Canvas}
 *
 */
function mainEntrance() {
  // The drawing canvas
  let canvas = document.querySelector("#theCanvas");
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  // The regl objects
  let { regl, drawEdge } = edgeRenderProgram(canvas);

  // Pause the animation
  let run = true;

  /**
   * &lt;p>The mousedown event is fired at an Element when a pointing device button is pressed
   * while the pointer is inside the element.&lt;/p>
   *
   * Pauses/resumes the animation whenever the mouse left button is clicked into the canvas.
   *
   * @param {MouseEvent} event mouse event.
   * @event onmousedown
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event mousedown event}
   */
  canvas.onmousedown = (event) => {
    if (event.button == 0) {
      run = !run;
    }
  };

  // A set of edge lights
  let edges = [new edgeLight()];
  const maxEdges = 40;
  const minEdges = 4;
  const createProbability = 0.02;
  const ae = document.querySelector("#attenuation");
  const lt = document.querySelector("#light");
  const beam = document.querySelector("#beam");

  regl.frame(function () {
    if (!run) return;

    regl.clear({
      color: [0, 0, 0, 1],
    });

    //drawEdge(edges);
    for (let edge of edges) {
      drawEdge({
        a: edge.a,
        b: edge.b,
        color: edge.color,
        attenuationExponent: +ae.value,
        lightIntensity: +lt.value,
        beamLength: +beam.value,
      });
      edge.animate();
    }
    edges = edges.filter((e) => !e.terminated);
    if (
      edges.length &lt; maxEdges &amp;&amp;
      (edges.length &lt; minEdges || Math.random() &lt; createProbability)
    )
      edges.push(new edgeLight());
  });
}

/**
 * Loads the {@link mainEntrance application}.
 * @param {Event} event load event.
 * @event load
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event load event}
 */
addEventListener("load", (event) => mainEntrance());
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-d3.html">d3</a></li></ul><h3>Classes</h3><ul><li><a href="edgeLight.html">edgeLight</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:load">load</a></li><li><a href="global.html#event:onmousedown">onmousedown</a></li></ul><h3>Global</h3><ul><li><a href="global.html#edgeRenderProgram">edgeRenderProgram</a></li><li><a href="global.html#mainEntrance">mainEntrance</a></li><li><a href="global.html#palette">palette</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sat Apr 20 2024 21:38:16 GMT-0300 (Brasilia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
