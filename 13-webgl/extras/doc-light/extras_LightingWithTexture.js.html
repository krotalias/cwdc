<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: extras/LightingWithTexture.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: extras/LightingWithTexture.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 *
 * Summary.
 * &lt;p>Lighting, combined with {@link https://web.engr.oregonstate.edu/~mjb/cs550/PDFs/TextureMapping.4pp.pdf texture mapping}.&lt;/p>
 *
 * &lt;p>&lt;b>For Educational Purposes Only.&lt;/b>&lt;/p>
 * &lt;p>This is just a &lt;b>demo&lt;/b> for teaching {@link https://en.wikipedia.org/wiki/Computer_graphics CG},
 * which became overly complicated, and it is similar to &lt;a href="/cwdc/13-webgl/examples/lighting/content/doc-lighting2/index.html">Lighting2&lt;/a>,
 * except we define a 3x3 matrix for {@link https://learnopengl.com/Lighting/Materials material properties}
 * and a 3x3 matrix for {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL light properties}
 * that are passed to the fragment shader as
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform uniforms}.&lt;p>
 *
 * Texture coordinates can be set in each model or be sampled at each pixel in the fragment shader.
 * We can also approximate a sphere by subdividing a
 * {@link https://en.wikipedia.org/wiki/Regular_polyhedron convex regular polyhedron}, and solve Mipmapping artifact issues,
 * by using {@link https://vcg.isti.cnr.it/Publications/2012/Tar12/jgt_tarini.pdf Tarini's} method, in this case.
 * These {@link https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b artifacts}
 * show up due to the discontinuity in the seam, when crossing the line with 0 radians on one side and to 2Ï€ on the other.
 * It is possible that some triangles have edges that cross this line, causing the wrong mipmap level 0 to be chosen.
 *
 * &lt;p>Edit the {@link lightPropElements light}/{@link matPropElements material} matrices in the global variables to experiment.
 * Edit {@link startForReal} to choose a model and select
 * {@link https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/shading-normals face or vertex normals}.
 * In fact, {@link https://threejs.org Three.js} only uses face normals for
 * {@link https://threejs.org/docs/#api/en/geometries/PolyhedronGeometry polyhedra}.&lt;p>
 *
 * To lay a map onto a sphere, textures should have an aspect ratio of 2:1 for equirectangular projections,
 * or 1:1 (squared) for Mercator projections. Finding high resolution, good quality,
 * and free {@link https://www.axismaps.com/guide/map-projections cartographic maps}
 * is very, really very difficult.
 *
 * &lt;p>{@link https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/mercator-its-not-hip-to-be-square/ Mercator texture coordinates}
 * can only be set for a sphere created by subdividing
 * a {@link polyhedron#tetrahedron tetrahedron} or an {@link polyhedron#octahedron octahedron}.
 * For all the other {@link getModelData models}, the solution is using
 * the &lt;a href="../../showCode.php?f=extras/LightingWithTexture">shader&lt;/a>
 * that samples texture coordinates for each pixel.&lt;/p>
 *
 * Since a unit sphere fits in WebGL {@link https://carmencincotti.com/2022-11-28/from-clip-space-to-ndc-space/ NDC space},
 * then, for each fragment, one can go from:
 * &lt;ul>
 *   &lt;li> cartesian â†’ spherical (equirectangular) â†’ Mercator &lt;/li>
 *   &lt;li> (x, y, z) â†’ (long, lat) â†’ (x, y) &lt;/li>
 *   &lt;li> sample texture at (x, y)&lt;/li>
 * &lt;/ul>
 *
 * @author Paulo Roma
 * @license Licensed under the {@link https://www.opensource.org/licenses/mit-license.php MIT license}.
 * @copyright 2024 Paulo R Cavalcanti.
 * @since 30/01/2016
 * @see &lt;a href="/cwdc/13-webgl/extras/LightingWithTexture.html">link&lt;/a> - Texture coordinates sampled at each pixel in the fragment shader:
 * @see &lt;a href="/cwdc/13-webgl/extras/LightingWithTexture2.html">link2&lt;/a> - Texture coordinates sampled at each vertex in the vertex shader
 * @see &lt;a href="https://math.rice.edu/~polking/cartography/cart.pdf">Mapping the Sphere&lt;a/>
 * @see &lt;a href="https://maa.org/sites/default/files/pdf/upload_library/22/Ford/Apostol496-508.pdf">A Fresh Look at the Method of Archimedes&lt;/a>
 * @see &lt;a href="https://djalil.chafai.net/blog/wp-content/uploads/2011/11/Letac-From-Archimedes-to-Statistics-The-area-of-the-sphere.pdf">From Archimedes to statistics: the area of the sphere&lt;/a>
 * @see &lt;a href="https://cuhkmath.wordpress.com/2018/01/05/archimedes-and-the-area-of-sphere/">Archimedes and the area of sphere&lt;/a>
 * @see &lt;a href="https://math.uit.no/ansatte/dennis/MoMS2017-Lec3.pdf">The Mathematics of Maps&lt;/a>
 * @see &lt;a href="https://globe-3d-2m2vlb3ft.now.sh">Globe 3D&lt;/a>
 * @see {@link https://www.thetruesize.com/ The True Size of ...}
 * @see {@link https://en.wikipedia.org/wiki/Sextant Navigational Sextant}
 * @see &lt;a href="/cwdc/13-webgl/extras/textures">textures&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/extras/LightingWithTexture.js">source&lt;/a>
 * @see &lt;figure>
 *      &lt;img src="../images/teapot.png" height="310" title="Utah teapot">
 *      &lt;img src="../images/tex.png" title="64x64 texture" height="310">
 *      &lt;figcaption style="font-size: 200%">{@link cartesian2Spherical North Pole - Y axis}&lt;/figcaption>
 *      &lt;/figure>
 * @see &lt;figure>
 *      &lt;img src="../textures/BigEarth.jpg" height="340" title="earth from nasa">
 *      &lt;img src="../images/spherical-projection.png" height="340" title="spherical projection">
 *      &lt;figcaption style="font-size: 200%">
 *      &lt;a href="https://en.wikipedia.org/wiki/Equirectangular_projection">Equirectangular projection&lt;/a>
 *      &lt;/figcaption>
 *      &lt;img src="../images/mercator-projection-world-map-political.png" height="340" title="mercator world map">
 *      &lt;img src="../images/Globe-Earth-land-distortion-projection-Mercator-latitudes.jpg" height="340" title="mercator projection">
 *      &lt;figcaption style="font-size: 200%">
 *      &lt;a href="https://www.britannica.com/science/Mercator-projection">Mercator Projection&lt;/a>
 *      &lt;/figcaption>
 *      &lt;/figure>
 * @see  &lt;figure>
 *      &lt;img src="../images/sphere-earth.png" height="340" title="equirectangular projection">
 *      &lt;img src="../images/teapot-earth.png" height="340" title="sphere projected onto a teapot">
 *      &lt;figcaption style="font-size: 200%">&lt;a href="https://people.computing.clemson.edu/~dhouse/courses/405/notes/texture-maps.pdf">Spherical (Equirectangular) Projection&lt;/a>&lt;/figcaption>
 *      &lt;/figure>
 * @see &lt;figure>
 *      &lt;img src="../images/aliasing-no-correction.png" height="340" title="spherical mapping discontinuity">
 *      &lt;img src="../images/GB.png" height="340" title="GhostBusters Seam">
 *      &lt;figcaption style="font-size: 200%">{@link polyhedron#tetrahedron Subdivision Sphere} Seam -
 *        &lt;a href="https://vcg.isti.cnr.it/Publications/2012/Tar12/jgt_tarini.pdf">Mipmapping Artifact&lt;/a>&lt;/figcaption>
 *      &lt;/figure>
 * @see &lt;figure>
 *      &lt;img src="../images/sphere.png" width="512" title="texture in fragment shader">
 *      &lt;img src="../images/anti-aliasing.png" height="340" title="sampling by pixel">&lt;br>
 *      &lt;img src="../images/Gordon_River.png" height="340" title="Gordon River">
 *      &lt;img src="../images/Milla.png" height="340" title="Milla Jovovich">
 *      &lt;figcaption style="font-size: 200%">{@link https://learnopengl.com/Getting-started/Textures Texture Sampled} in
 *        &lt;a href="/cwdc/13-webgl/showCode.php?f=extras/LightingWithTexture">Fragment Shader&lt;/a>&lt;/figcaption>
 *      &lt;figure>
 */

"use strict";

/**
 * 4x4 Matrix
 * @type {glMatrix.mat4}
 * @see {@link https://glmatrix.net/docs/module-mat4.html glMatrix.mat4}
 */
const mat4 = glMatrix.mat4;

/**
 * 3x3 Matrix
 * @type {glMatrix.mat3}
 * @see {@link https://glmatrix.net/docs/module-mat3.html glMatrix.mat3}
 */
const mat3 = glMatrix.mat3;

/**
 * Three.js module.
 * @external THREE
 * @see {@link https://threejs.org/docs/#manual/en/introduction/Installation Installation}
 * @see {@link https://discoverthreejs.com DISCOVER three.js}
 */

/**
 * &lt;p>A representation of mesh, line, or point geometry.&lt;/p>
 * Includes vertex positions, face indices, normals, colors, UVs,
 * and custom attributes within buffers, reducing the cost of
 * passing all this data to the GPU.
 * @class BufferGeometry
 * @memberof external:THREE
 * @see https://threejs.org/docs/#api/en/core/BufferGeometry
 */

/**
 * Array holding image file names to create textures.
 * @type {Array&lt;String>}
 */
var imageFilename = ["BigEarth.jpg"];

/**
 * Current texture index.
 * @type {Number}
 */
var textureCnt = 0;

/**
 * Texture image.
 * @type {HTMLImageElement}
 * @see {@link ImageLoadCallback}
 */
var image;

/**
 * Maximum Number of subdivisions to turn a polyhedron into a sphere.
 * @type {Number}
 */
let maxSubdivisions = limit.dod;

/**
 * Number of subdivisions to turn a polyhedron into a sphere.
 * @type {Number}
 */
let numSubdivisions = maxSubdivisions;

/**
 * Scale applied to a model to make its size adequate for rendering.
 * @type {Number}
 */
var mscale = 1;

/**
 * Number of segments for drawing a meridian or a parallel.
 * @type {Number}
 */
const nsegments = 36;

/**
 * GPS coordinates of the city location to be drawn.
 * @type {Object&lt;String:Object&lt;{latitude:Number,longitude:Number}>>}
 */
const gpsCoordinates = {
  Null_Island: {
    latitude: 0,
    longitude: 0,
  },
  Rio: {
    latitude: -22.9068,
    longitude: -43.1729,
  },
  NYC: {
    latitude: 40.7128,
    longitude: -74.006,
  },
  Syracuse: {
    latitude: 37.075474,
    longitude: 15.286586,
  },
  Calgary: {
    latitude: 51.049999,
    longitude: -114.066666,
  },
  Ames: {
    latitude: 42.034534,
    longitude: -93.620369,
  },
  Rome: {
    latitude: 41.902782,
    longitude: 12.496366,
  },
  Berlin: {
    latitude: 52.520008,
    longitude: 13.404954,
  },
  Hawaii: {
    latitude: 21.3068,
    longitude: -157.7912,
  },
};

/**
 * Name of the current city location.
 * @type {String}
 */
const currentLocation =
  Object.keys(gpsCoordinates)[
    Math.floor(Math.random() * Object.keys(gpsCoordinates).length)
  ];

/**
 * Display status of the model mesh, texture, axes and paused animation: on/off.
 * @type {Object&lt;{lines:Boolean, texture:Boolean, axes:Boolean, paused:Boolean}>}
 */
const selector = {
  lines: document.getElementById("mesh").checked,
  texture: document.getElementById("texture").checked,
  axes: document.getElementById("axes").checked,
  paused: document.getElementById("pause").checked,
  intrinsic: document.getElementById("intrinsic").checked,
  equator: document.getElementById("equator").checked,
};

/**
 * Arcball.
 * @type {SimpleRotator}
 */
var rotator;

/**
 * Vertex coordinates for creating the axes.
 * @type {Float32Array}
 */
// prettier-ignore
const axisVertices = new Float32Array([
  0.0, 0.0, 0.0,
  1.5, 0.0, 0.0,
  0.0, 0.0, 0.0,
  0.0, 1.5, 0.0,
  0.0, 0.0, 0.0,
  0.0, 0.0, 1.5
]);

/**
 * Colors for creating the axes.
 * @type {Float32Array}
 */
// prettier-ignore
const axisColors = new Float32Array([
  1.0, 0.0, 0.0, 1.0,
  1.0, 0.0, 0.0, 1.0,
  0.0, 1.0, 0.0, 1.0,
  0.0, 1.0, 0.0, 1.0,
  0.0, 0.0, 1.0, 1.0,
  0.0, 0.0, 1.0, 1.0
]);

// A few global variables...

/**
 * &lt;p>Light properties.&lt;/p>
 * Ambient, diffuse and specular.
 * &lt;p>Remember this is column major.&lt;/p>
 * @type {Object&lt;String:Float32Array>}
 */
// prettier-ignore
const lightPropElements = {
  // generic white light.
  white_light: new Float32Array([
                    0.5, 0.5, 0.5,
                    0.7, 0.7, 0.7,
                    0.7, 0.7, 0.7
  ]),

  // blue light with red specular highlights
  // (because we can)
  blue_red: new Float32Array([
                0.2, 0.2, 0.2,
                0.0, 0.0, 0.7,
                0.7, 0.0, 0.0
  ])
};

/**
 * &lt;p>Material properties.&lt;/p>
 * Ambient, diffuse and specular.
 * &lt;p>Remember this is column major.&lt;/p>
 * @type {Object&lt;String:Float32Array>}
 * @see {@link http://devernay.free.fr/cours/opengl/materials.html OpenGL/VRML Materials}
 * @see {@link https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html Material charts}
 */
// prettier-ignore
const matPropElements = {
  shiny_brass: new Float32Array([
                0.33, 0.22, 0.03,
                0.78, 0.57, 0.11,
                0.99, 0.91, 0.81
  ]),

  shiny_green_plastic: new Float32Array([
                        0.3, 0.3, 0.3,
                        0.0, 0.8, 0.0,
                        0.8, 0.8, 0.8
  ]),

  // very fake looking white
  // useful for testing lights
  fake_white: new Float32Array([
                  1, 1, 1,
                  1, 1, 1,
                  1, 1, 1
  ]),

  // clay or terracotta
  clay: new Float32Array([
        0.75, 0.38, 0.26,
        0.75, 0.38, 0.26,
        0.25, 0.20, 0.15 // weak specular highlight similar to diffuse color
  ]),
};

/**
 * &lt;p>Specular term exponent used in the
 * {@link https://en.wikipedia.org/wiki/Phong_reflection_model Phong reflection model}.&lt;/p>
 * One entry for each material property.
 * @type {Array&lt;Number>}
 */
const shininess = [28.0, 30, 20.0, 10.0, 200];

/**
 * The OpenGL context.
 * @type {WebGL2RenderingContext}
 */
var gl;

/**
 * Current model data.
 * @type {modelData}
 */
var theModel;

/**
 * Array with normal end points.
 * @type {Float32Array}
 */
var normal;

/**
 * Array with edges end points.
 * @type {Float32Array}
 */
var lines;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var vertexBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var vertexNormalBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var texCoordBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var indexBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var axisBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var normalBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var lineBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var parallelBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var meridianBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var axisColorBuffer;

/**
 * Handle to the texture object on the GPU.
 * @type {WebGLTexture}
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/createTexture
 */
var textureHandle;

/**
 * Handle to the compiled shader program on the GPU.
 * @type {WebGLShader}
 */
var lightingShader;

/**
 * Handle to the compiled shader program on the GPU.
 * @type {WebGLShader}
 */
var colorShader;

/**
 * Model matrix.
 * @type {mat4}
 */
var modelMatrix = mat4.create();
/**
 * Rotation axis.
 * @type {String}
 */
var axis = "x";

/**
 * Whether uv spherical coordinates should be "fixed",
 * when converted from cartesian
 * {@link https://vcg.isti.cnr.it/Publications/2012/Tar12/jgt_tarini.pdf (seamless)}.
 * @type {Boolean}
 * @see {@link https://forum.unity.com/threads/what-is-this-mipmap-artifact.657052/ What is this mipmap artifact?}
 * @see {@link https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b Distinctive Derivative Differences}
 */
var fixuv = document.querySelector("#fixuv").checked;

/**
 * Whether to use a
 * {@link https://en.wikipedia.org/wiki/Mercator_projection Mercator projection}.
 * @type {Boolean}
 * @see {@link https://globe-3d-2m2vlb3ft.now.sh Globe}
 * @see {@link https://forum.unity.com/threads/unity-shader-map-projection-mercator-to-equirectangular-or-lambert-azimuthal-equal-area.813987/ Unity shader, Mercator to equirectangular}
 */
var mercator = document.querySelector("#mercator").checked;

/**
 * Toggle back face culling on/off.
 * @type {Boolean}
 * @see {@link https://learnopengl.com/Advanced-OpenGL/Face-culling Face culling}
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/frontFace
 */
var culling = true;

/**
 * Camera position.
 * @type {vec3}
 */
var eye = vec3.fromValues(1.77, 3.54, 3.0);

/**
 * View matrix.
 * @type {mat4}
 * @see &lt;a href="/cwdc/downloads/apostila.pdf#page=109">View matrix&lt;/a>
 * @see &lt;a href="/cwdc/downloads/PDFs/06_LCG_Transformacoes.pdf">MudanÃ§a de Base&lt;/a>
 * @see &lt;a href="https://en.wikipedia.org/wiki/Change_of_basis">Change of Basis&lt;/a>
 * @see {@link https://learn.microsoft.com/en-us/windows/win32/direct3d9/view-transform View Transform (Direct3D 9)}
 */
// prettier-ignore
var viewMatrix = mat4.lookAt(
  [],
  eye,                        // eye
  vec3.fromValues(0, 0, 0),   // at - looking at the origin
  vec3.fromValues(0, 1, 0)    // up vector - y axis
);

/**
 * Projection matrix.
 * @type {mat4}
 */
var projection = mat4.perspectiveNO([], (30 * Math.PI) / 180, 1.5, 0.1, 1000);

/**
 * &lt;p>Promise for returning an array with all file names in directory './textures'.&lt;/p>
 *
 * &lt;p>Calls a php script via ajax, since Javascript doesn't have access to the filesystem.&lt;/p>
 * Please, note that php runs on the server, and javascript on the browser.
 * @type {Promise&lt;Array&lt;String>>}
 * @see &lt;a href="/cwdc/6-php/readFiles_.php">files&lt;/a>
 * @see {@link https://stackoverflow.com/questions/31274329/get-list-of-filenames-in-folder-with-javascript Get list of filenames in folder with Javascript}
 * @see {@link https://api.jquery.com/jquery.ajax/ jQuery.ajax()}
 */
var readFileNames = new Promise((resolve, reject) => {
  $.ajax({
    type: "GET",
    url: "/cwdc/6-php/readFiles_.php",
    data: {
      dir: "/cwdc/13-webgl/extras/textures",
    },
  })
    .done(function (fileNames) {
      resolve(JSON.parse(fileNames));
    })
    .fail(function (jqXHR, textStatus, errorThrown) {
      console.log(
        `[jqResponse: ${JSON.stringify(
          jqXHR,
          null,
          4,
        )}], \n[status: ${textStatus}], \n[error: ${errorThrown}]`,
      );
      console.log("Could not get data");
      reject("Could not get data");
    });
});

/**
 * Given an instance of
 * &lt;ul>
 * &lt;li>{@link external:THREE.BufferGeometry THREE.BufferGeometry}&lt;/li>
 * &lt;/ul>
 * returns an object containing raw data for
 * vertices, normal vectors, texture coordinates, and indices.
 * &lt;p>{@link https://threejs.org/docs/#api/en/geometries/PolyhedronGeometry Polyhedra} have no index.&lt;/p>
 * @param {external:THREE.BufferGeometry} geom
 *        {@link https://threejs.org/docs/#api/en/geometries/BoxGeometry THREE.BoxGeometry}&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/CapsuleGeometry THREE.CapsuleGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/ConeGeometry THREE.ConeGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/CylinderGeometry THREE.CylinderGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/PlaneGeometry THREE.PlaneGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/RingGeometry THREE.RingGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/SphereGeometry THREE.SphereGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/TorusGeometry THREE.TorusGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/TorusKnotGeometry THREE.TorusKnotGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/DodecahedronGeometry THREE.DodecahedronGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/IcosahedronGeometry THREE.IcosahedronGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/OctahedronGeometry THREE.OctahedronGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/TetrahedronGeometry THREE.TetrahedronGeometry},&lt;br>
 *        {@link TeapotGeometry THREE.TeapotGeometry}.
 * @return {modelData}
 */
function getModelData(geom) {
  return {
    vertexPositions: geom.getAttribute("position").array,
    vertexNormals: geom.getAttribute("normal").array,
    vertexTextureCoords: geom.getAttribute("uv").array,
    indices: geom.index ? geom.index.array : null,
  };
}

/**
 * &lt;p>Matrix for taking normals into eye space.&lt;/p>
 * Return a matrix to transform normals, so they stay
 * perpendicular to surfaces after a linear transformation.
 * @param {mat4} model model matrix.
 * @param {mat4} view view matrix.
 * @returns {mat3} 3x3 normal matrix (transpose inverse) from the 4x4 modelview matrix.
 * @see &lt;a href="/cwdc/13-webgl/extras/doc/gdc12_lengyel.pdf#page=48">ð‘›â€²=(ð‘€&lt;sup>&amp;#8211;1&lt;/sup>)&lt;sup>ð‘‡&lt;/sup>â‹…ð‘›&lt;/a>
 */
function makeNormalMatrixElements(model, view) {
  var modelview = mat4.multiply([], view, model);
  return mat3.normalFromMat4([], modelview);
}

/**
 * Translate keydown events to strings.
 * @param {KeyboardEvent} event keyboard event.
 * @return {String | null}
 * @see http://javascript.info/tutorial/keyboard-events
 */
function getChar(event) {
  event = event || window.event;
  let charCode = event.key || String.fromCharCode(event.which);
  return charCode;
}

/**
 * &lt;p>Closure for keydown events.&lt;/p>
 * Chooses a {@link theModel model} and which {@link axis} to rotate around.&lt;br>
 * The {@link numSubdivisions subdivision level} is {@link maxSubdivisions limited}
 * for a chosen subdivision polyhedron.&lt;br>
 * When a new texture is selected, triggers callback {@link image} load event.
 * @param {KeyboardEvent} event keyboard event.
 * @function
 * @return {key_event} callback for handling a keyboard event.
 */
const handleKeyPress = ((event) => {
  const mod = (n, m) => ((n % m) + m) % m;
  let kbd = document.getElementById("kbd");
  let opt = document.getElementById("options");
  let models = document.getElementById("models");
  let zoomfactor = 0.7;
  let gscale = 1;
  let subPoly = 0;
  const polyName = {
    0: "dodecahedron",
    1: "icosahedron",
    2: "octahedron",
    3: "tetrahedron",
  };
  const ntri = (p, n, f) => {
    if (p &lt; 2) return f * (n * n + 2 * n + 1);
    else return f * 4 ** n;
  };

  /**
   * &lt;p>Handler for keydown events.&lt;/p>
   * @param {KeyboardEvent} event keyboard event.
   * @callback key_event callback to handle a key pressed.
   */
  return (event) => {
    const ch = getChar(event);
    switch (ch) {
      case "m":
      case "M":
        let inc = ch == "m" ? 1 : -1;
        numSubdivisions = mod(numSubdivisions + inc, maxSubdivisions + 1);
        gscale = mscale = 1;
        if (numSubdivisions == 0) {
          models.value = subPoly + 9;
        } else {
          models.value = "13";
        }
        theModel = createModel({ poly: subPoly });

        kbd.innerHTML = `
          (${polyName[subPoly]}
          level ${numSubdivisions} â†’
          ${ntri(subPoly, numSubdivisions, theModel.nfaces)} triangles):`;
        break;
      case " ":
        selector.paused = !selector.paused;
        document.getElementById("pause").checked = selector.paused;
        if (!selector.paused) document.getElementById(axis).checked = true;
        animate();
        return;
      case "l":
        selector.lines = !selector.lines;
        if (!selector.lines) selector.texture = true;
        document.getElementById("mesh").checked = selector.lines;
        document.getElementById("texture").checked = selector.texture;
        break;
      case "k":
        selector.texture = !selector.texture;
        if (!selector.texture) selector.lines = true;
        document.getElementById("texture").checked = selector.texture;
        document.getElementById("mesh").checked = selector.lines;
        break;
      case "a":
        selector.axes = !selector.axes;
        document.getElementById("axes").checked = selector.axes;
        break;
      case "x":
      case "y":
      case "z":
        axis = ch;
        selector.paused = false;
        document.getElementById(axis).checked = true;
        animate();
        break;
      case "I":
        selector.intrinsic = true;
        document.getElementById("intrinsic").checked = true;
        animate();
        break;
      case "e":
        selector.intrinsic = false;
        document.getElementById("extrinsic").checked = true;
        animate();
        break;
      case "E":
        selector.equator = !selector.equator;
        document.getElementById("equator").checked = selector.equator;
        animate();
        break;
      case "s":
        // sphere from threejs
        gscale = mscale = 1;
        models.value = "5";
        theModel = createModel({
          shape: getModelData(new THREE.SphereGeometry(1, 48, 24)),
          // shape: uvSphere(1, 48, 24),
        });
        break;
      case "S":
        // subdivision sphere
        this.mscale = mscale = 1;
        numSubdivisions = maxSubdivisions;
        models.value = "13";
        theModel = createModel({ poly: subPoly });
        kbd.innerHTML = `
          (${polyName[subPoly]}
          level ${numSubdivisions} â†’
          ${ntri(subPoly, numSubdivisions, theModel.nfaces)} triangles):`;
        break;
      case "T":
        gscale = mscale = 0.6;
        models.value = "8";
        theModel = createModel({
          shape: getModelData(new THREE.TorusKnotGeometry(1, 0.4, 128, 16)),
        });
        break;
      case "t":
        gscale = mscale = 1;
        models.value = "7";
        theModel = createModel({ shape: uvTorus(1, 0.5, 30, 30), chi: 0 });
        break;
      case "u":
        // capsule from threejs
        gscale = mscale = 1.2;
        models.value = "0";
        theModel = createModel({
          shape: getModelData(new THREE.CapsuleGeometry(0.5, 0.5, 10, 20)),
        });
        break;
      case "c":
        gscale = mscale = 0.75;
        models.value = "3";
        theModel = createModel({
          // shape: uvCylinder(1, 2, 30, false, false),
          shape: getModelData(
            new THREE.CylinderGeometry(1, 1, 2, 30, 1, false),
          ),
        });
        break;
      case "C":
        gscale = mscale = 0.8;
        models.value = "1";
        theModel = createModel({
          // shape: uvCone(1, 2, 30, false),
          shape: getModelData(new THREE.ConeGeometry(1, 2, 30, 5, false)),
        });
        break;
      case "v":
        gscale = mscale = 0.6;
        models.value = "2";
        theModel = createModel({ shape: cube(2) });
        break;
      case "p":
        // teapot - this is NOT a manifold model - it is a model with borders!
        gscale = mscale = 0.1;
        models.value = "6";
        theModel = createModel({ shape: teapotModel, chi: null });
        break;
      case "P":
        // teapot - this is NOT a manifold model - it is a model with borders!
        gscale = mscale = 0.8;
        models.value = "6";
        theModel = createModel({
          shape: getModelData(
            new THREE.TeapotGeometry(1, 10, true, true, true, true, true),
          ),
          chi: null,
        });
        break;
      case "d":
        gscale = mscale = 1;
        subPoly = 0;
        maxSubdivisions = limit.dod;
        numSubdivisions = 0;
        models.value = "9";
        theModel = createModel({
          shape: getModelData(new THREE.DodecahedronGeometry(1, 0)),
        });
        kbd.innerHTML = ":";
        break;
      case "i":
        gscale = mscale = 1;
        subPoly = 1;
        maxSubdivisions = limit.ico;
        numSubdivisions = 0;
        models.value = "10";
        theModel = createModel({
          shape: getModelData(new THREE.IcosahedronGeometry(1, 0)),
        });
        kbd.innerHTML = ":";
        break;
      case "o":
        gscale = mscale = 1;
        subPoly = 2;
        maxSubdivisions = limit.oct;
        numSubdivisions = 0;
        models.value = "11";
        theModel = createModel({
          shape: getModelData(new THREE.OctahedronGeometry(1, 0)),
        });
        kbd.innerHTML = ":";
        break;
      case "w":
        gscale = mscale = 1;
        subPoly = 3;
        maxSubdivisions = limit.tet;
        numSubdivisions = 0;
        models.value = "12";
        theModel = createModel({
          shape: getModelData(new THREE.TetrahedronGeometry(1, 0)),
        });
        kbd.innerHTML = ":";
        break;
      case "r":
        gscale = mscale = 1.0;
        models.value = "4";
        theModel = createModel({
          shape: getModelData(
            new THREE.RingGeometry(0.3, 1.0, 30, 30, 0, 6.283185307179586),
          ),
          chi: 0,
        });
        break;
      case "O":
        mat4.identity(modelMatrix);
        rotator.setViewMatrix(modelMatrix);
        mscale = gscale;
        break;
      case "n":
      case "N":
        let incr = ch == "n" ? 1 : -1;
        textureCnt = mod(textureCnt + incr, imageFilename.length);
        image.src = `./textures/${imageFilename[textureCnt]}`;
        mercator = imageFilename[textureCnt].includes("Mercator");
        document.getElementById("mercator").checked = mercator;
        return;
      case "f":
        fixuv = !fixuv;
        // reload texture with or without fixing
        image.src = `./textures/${imageFilename[textureCnt]}`;
        document.getElementById("fixuv").checked = fixuv;
        setUVfix();
        break;
      case "g":
        mercator = !mercator;
        document.getElementById("mercator").checked = mercator;
        break;
      case "b":
        culling = !culling;
        if (culling) gl.enable(gl.CULL_FACE);
        else gl.disable(gl.CULL_FACE);
        document.getElementById("culling").checked = culling;
        break;
      case "ArrowUp":
        mscale *= zoomfactor;
        mscale = Math.max(gscale * 0.1, mscale);
        break;
      case "ArrowDown":
        mscale /= zoomfactor;
        mscale = Math.min(gscale * 3, mscale);
        break;
      default:
        return;
    }
    opt.innerHTML = `&lt;br>${gl.getParameter(
      gl.SHADING_LANGUAGE_VERSION,
    )}&lt;br>${gl.getParameter(gl.VERSION)}`;
    if (selector.paused) draw();
  };
})();

/**
 * Select a texture from menu.
 */
function selectTexture() {
  const selectElement = document.getElementById("textures");
  textureCnt = +selectElement.value;
  image.src = `./textures/${imageFilename[textureCnt]}`;
  mercator = imageFilename[textureCnt].includes("Mercator");
  document.getElementById("mercator").checked = mercator;
}

/**
 * Returns a new keyboard event
 * that can be passed to {@link handleKeyPress}.
 * @param {String} key char code.
 * @returns {KeyboardEvent} a keyboard event.
 */
const createEvent = (key) => {
  let code = key.charCodeAt();
  return new KeyboardEvent("keydown", {
    key: key,
    which: code,
    charCode: code,
    keyCode: code,
  });
};

/**
 * Selects a model from a menu and creates an {@link createEvent event} for it.
 */
function selectModel() {
  let val = document.getElementById("models").value;
  let key = {
    0: "u", // capsule
    1: "C", // cone
    2: "v", // cube
    3: "c", // cylinder
    4: "r", // ring
    5: "s", // sphere
    6: "P", // teapot
    7: "t", // torus
    8: "T", // knot
    9: "d", // dodecahedron
    10: "i", // icosahedron
    11: "o", // octahedron
    12: "w", // tetrahedron
    13: "S", // subdivision sphere
  };
  handleKeyPress(createEvent(key[val]));
}

/**
 * Select next texture and creates an {@link createEvent event} "n" for it.
 */
function nextTexture() {
  handleKeyPress(createEvent("n"));
}

/**
 * Select previous texture and creates an {@link createEvent event} "N" for it.
 */
function previousTexture() {
  handleKeyPress(createEvent("N"));
}

/**
 * Select next subdivision level and creates an {@link createEvent event} "m" for it.
 */
function nextLevel() {
  handleKeyPress(createEvent("m"));
}

/**
 * Select previous subdivision level and creates an {@link createEvent event} "M" for it.
 */
function previousLevel() {
  handleKeyPress(createEvent("M"));
}

/**
 * Increase zoom level and creates an {@link createEvent event} â†“ for it.
 */
function zoomIn() {
  handleKeyPress(createEvent("ArrowDown"));
}

/**
 * Decrease zoom level and creates an {@link createEvent event} â†‘ for it.
 */
function zoomOut() {
  handleKeyPress(createEvent("ArrowUp"));
}

const mesh = document.getElementById("mesh");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the mesh checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
mesh.addEventListener("change", (event) => handleKeyPress(createEvent("l")));

const axes = document.getElementById("axes");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the axes checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
axes.addEventListener("change", (event) => handleKeyPress(createEvent("a")));

const equator = document.getElementById("equator");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the equator checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
equator.addEventListener("change", (event) => handleKeyPress(createEvent("E")));

if (document.querySelector('input[name="rot"]')) {
  document.querySelectorAll('input[name="rot"]').forEach((elem) => {
    /**
     * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
     * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
     * the event is dispatched.&lt;/p>
     *
     * @event change - executed when the rot input radio is checked (but not when unchecked).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
     */
    elem.addEventListener("change", function (event) {
      var item = event.target.value;
      handleKeyPress(createEvent(item));
    });
  });
}

if (document.querySelector('input[name="mode"]')) {
  document.querySelectorAll('input[name="mode"]').forEach((elem) => {
    /**
     * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
     * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
     * the event is dispatched.&lt;/p>
     *
     * @event change - executed when the mode input radio is checked (but not when unchecked).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
     */
    elem.addEventListener("change", function (event) {
      var item = event.target.value;
      handleKeyPress(createEvent(item));
    });
  });
}

const fix_uv = document.getElementById("fixuv");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the fix_uv checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
fix_uv.addEventListener("change", (event) => handleKeyPress(createEvent("f")));

const merc = document.getElementById("mercator");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the mercator checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
merc.addEventListener("change", (event) => handleKeyPress(createEvent("g")));

const cull = document.getElementById("culling");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the cull checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
cull.addEventListener("change", (event) => handleKeyPress(createEvent("b")));

const texture = document.getElementById("texture");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the texture checkbox is checked or unchecked.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
texture.addEventListener("change", (event) => handleKeyPress(createEvent("k")));

const textures = document.getElementById("textures");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link selectTexture} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the textures &amp;lt;select&amp;gt; is changed.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
textures.addEventListener("change", (event) => {
  selectTexture();
  document.activeElement.blur();
});

const models = document.getElementById("models");

/**
 * &lt;p>Appends an event listener for events whose type attribute value is change.&lt;br>
 * The {@link selectModel} argument sets the callback that will be invoked when
 * the event is dispatched.&lt;/p>
 *
 * @event change - executed when the models &amp;lt;select&amp;gt; is changed.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
 */
models.addEventListener("change", (event) => selectModel());

/**
 * Code to actually render our geometry.
 * Draws axes, applies texture, then draws lines.
 */
function draw() {
  // clear the framebuffer
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  if (selector.axes) drawAxes();
  if (selector.texture) drawTexture();
  if (selector.lines) drawLines();
  if (selector.equator) drawParallel();
}

/**
 * Returns a new scale model matrix, which applies {@link mscale}.
 * @returns {mat4} model matrix.
 */
function getModelMatrix() {
  var m = modelMatrix;
  if (mscale != 1) {
    m = mat4.multiply(
      [],
      modelMatrix,
      mat4.fromScaling([], vec3.fromValues(mscale, mscale, mscale)),
    );
  }
  return m;
}

/**
 * &lt;p>Texture render the current model.&lt;/p>
 * Uses the {@link lightingShader}.
 *
 * &lt;p>If the attribute "a_TexCoord" is not defined in the vertex shader,
 * texture coordinates will be calculated pixel by pixel
 * in the fragment shader.&lt;/p>
 *
 * &lt;p> We can also set a uniform attribute (u_mercator) in the shader,
 * for using a {@link https://hrcak.srce.hr/file/239690 Mercator projection}
 * instead of an {@link https://en.wikipedia.org/wiki/Equirectangular_projection equirectangular projection}.&lt;/p>
 */
function drawTexture() {
  // bind the shader
  gl.useProgram(lightingShader);

  // get the index for the a_Position attribute defined in the vertex shader
  var positionIndex = gl.getAttribLocation(lightingShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var normalIndex = gl.getAttribLocation(lightingShader, "a_Normal");
  if (normalIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Normal");
    return;
  }

  var texCoordIndex = gl.getAttribLocation(lightingShader, "a_TexCoord");
  var noTexture = texCoordIndex &lt; 0;

  var u_mercator = gl.getUniformLocation(lightingShader, "u_mercator");
  gl.uniform1i(u_mercator, mercator);

  // "enable" the a_position attribute
  gl.enableVertexAttribArray(positionIndex);
  gl.enableVertexAttribArray(normalIndex);
  // texture coordinates can be calculated in the fragment shader
  if (!noTexture) gl.enableVertexAttribArray(texCoordIndex);

  // bind buffers for points
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
  gl.vertexAttribPointer(normalIndex, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  if (!noTexture)
    gl.vertexAttribPointer(texCoordIndex, 2, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // set uniform in shader for projection * view * model transformation
  var loc = gl.getUniformLocation(lightingShader, "model");
  gl.uniformMatrix4fv(loc, false, getModelMatrix());
  loc = gl.getUniformLocation(lightingShader, "view");
  gl.uniformMatrix4fv(loc, false, viewMatrix);
  loc = gl.getUniformLocation(lightingShader, "projection");
  gl.uniformMatrix4fv(loc, false, projection);
  loc = gl.getUniformLocation(lightingShader, "normalMatrix");
  gl.uniformMatrix3fv(
    loc,
    false,
    makeNormalMatrixElements(modelMatrix, viewMatrix),
  );

  loc = gl.getUniformLocation(lightingShader, "lightPosition");
  gl.uniform4f(loc, 2.0, 4.0, 2.0, 1.0);

  // light and material properties
  loc = gl.getUniformLocation(lightingShader, "lightProperties");
  gl.uniformMatrix3fv(loc, false, lightPropElements.white_light);
  loc = gl.getUniformLocation(lightingShader, "materialProperties");
  gl.uniformMatrix3fv(loc, false, matPropElements.shiny_brass);
  loc = gl.getUniformLocation(lightingShader, "shininess");
  gl.uniform1f(loc, shininess[shininess.length - 1]);

  // need to choose a texture unit, then bind the texture to TEXTURE_2D for that unit
  var textureUnit = 1;
  gl.activeTexture(gl.TEXTURE0 + textureUnit);
  gl.bindTexture(gl.TEXTURE_2D, textureHandle);
  loc = gl.getUniformLocation(lightingShader, "sampler");
  gl.uniform1i(loc, textureUnit);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  if (theModel.indices) {
    gl.drawElements(
      gl.TRIANGLES,
      theModel.indices.length,
      theModel.indices.constructor === Uint32Array
        ? gl.UNSIGNED_INT
        : gl.UNSIGNED_SHORT,
      0,
    );
  } else {
    gl.drawArrays(gl.TRIANGLES, 0, theModel.vertexPositions.length / 3);
  }

  gl.disableVertexAttribArray(positionIndex);
  gl.disableVertexAttribArray(normalIndex);
  if (!noTexture) gl.disableVertexAttribArray(texCoordIndex);
  gl.useProgram(null);
}

/**
 * &lt;p>Draws the lines: mesh + normals.&lt;/p>
 * Uses the {@link colorShader}.
 * &lt;p>This code takes too long on mobile - too many API calls.&lt;/p>
 * &lt;pre>
 *  // draw edges
 *  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
 *  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
 *  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
 *  for (var i = 0; i &lt; theModel.indices.length; i += 3) {
 *      // offset - two bytes per index (UNSIGNED_SHORT)
 *      gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i * 2);
 *  }
 * &lt;/pre>
 * The solution is having a single {@link lineBuffer buffer} with all lines,
 * which was set in {@link createModel}.
 * @see {@link https://stackoverflow.com/questions/47232671/how-gl-drawelements-find-the-corresponding-vertices-array-buffer How gl.drawElements "find" the corresponding vertices array buffer?}
 */
function drawLines() {
  // bind the shader
  gl.useProgram(colorShader);

  var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var a_color = gl.getAttribLocation(colorShader, "a_Color");
  if (a_color &lt; 0) {
    console.log("Failed to get the storage location of a_Color");
    return;
  }

  // use yellow as line color in the colorShader
  gl.vertexAttrib4f(a_color, 1.0, 1.0, 0.0, 1.0);

  // "enable" the a_position attribute
  gl.enableVertexAttribArray(positionIndex);

  //  ------------ draw triangle borders
  // set transformation to projection * view * model
  var loc = gl.getUniformLocation(colorShader, "transform");
  var transform = mat4.multiply(
    [],
    projection,
    mat4.multiply([], viewMatrix, getModelMatrix()),
  );
  gl.uniformMatrix4fv(loc, false, transform);

  // draw edges - single pre-computed lineBuffer
  let len = theModel.indices
    ? theModel.indices.length
    : theModel.vertexPositions.length;
  gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.LINES, 0, 2 * len);

  // draw normals
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.LINES, 0, 2 * theModel.vertexPositions.length);

  gl.disableVertexAttribArray(positionIndex);
  gl.useProgram(null);
}

/**
 * &lt;p>Draws the axes. &lt;/p>
 * Uses the {@link colorShader}.
 */
function drawAxes() {
  // bind the shader
  gl.useProgram(colorShader);

  var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var colorIndex = gl.getAttribLocation(colorShader, "a_Color");
  if (colorIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Color");
    return;
  }

  gl.enableVertexAttribArray(positionIndex);
  gl.enableVertexAttribArray(colorIndex);
  // draw axes (not transformed by model transformation)
  gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, axisColorBuffer);
  gl.vertexAttribPointer(colorIndex, 4, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // set transformation to projection * view only for extrinsic
  var loc = gl.getUniformLocation(colorShader, "transform");
  var transform = mat4.multiply([], projection, viewMatrix);
  // set transformation to projection * view * model for intrinsic
  if (selector.intrinsic) {
    mat4.multiply(transform, transform, modelMatrix);
  }
  gl.uniformMatrix4fv(loc, false, transform);

  // draw axes
  gl.drawArrays(gl.LINES, 0, 6);

  // unbind shader and "disable" the attribute indices
  // (not really necessary when there is only one shader)
  gl.disableVertexAttribArray(positionIndex);
  gl.disableVertexAttribArray(colorIndex);
  gl.useProgram(null);
}

/**
 * &lt;p>Draws a parellel. &lt;/p>
 * Uses the {@link colorShader}.
 */
function drawParallel() {
  // bind the shader
  gl.useProgram(colorShader);
  var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var a_color = gl.getAttribLocation(colorShader, "a_Color");
  if (a_color &lt; 0) {
    console.log("Failed to get the storage location of a_Color");
    return;
  }
  gl.vertexAttrib4f(a_color, 1.0, 0.0, 0.0, 1.0);

  // "enable" the a_position attribute
  gl.enableVertexAttribArray(positionIndex);

  // set transformation to projection * view * model
  var loc = gl.getUniformLocation(colorShader, "transform");
  var transform = mat4.multiply(
    [],
    projection,
    mat4.multiply([], viewMatrix, getModelMatrix()),
  );
  gl.uniformMatrix4fv(loc, false, transform);

  // draw parallel
  gl.bindBuffer(gl.ARRAY_BUFFER, parallelBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.LINE_LOOP, 0, nsegments);

  // draw meridian
  gl.bindBuffer(gl.ARRAY_BUFFER, meridianBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.LINE_LOOP, 0, nsegments);

  gl.disableVertexAttribArray(positionIndex);
  gl.useProgram(null);
}

/**
 * Get texture file names from an html &amp;lt;select&amp;gt; element
 * identified by "textures".
 * @param {Array&lt;String>} optionNames array of texture file names.
 */
function getTextures(optionNames) {
  optionNames.length = 0;
  const selectElement = document.getElementById("textures");
  [...selectElement.options].map((o) => optionNames.push(o.text));
}

/**
 * Set texture file names of an html &amp;lt;select&amp;gt; element identified by "textures".
 * @param {Array&lt;String>} optionNames array of texture file names.
 */
function setTextures(optionNames) {
  const sel = document.getElementById("textures");

  let options_str = "";

  optionNames.forEach((img, index) => {
    options_str += `&lt;option value="${index}">${img}&lt;/option>`;
  });

  sel.innerHTML = options_str;
}

/**
 * &lt;p>Loads the texture image asynchronously and defines its {@link ImageLoadCallback load callback function}.&lt;/p>
 * @param {Event} event load event.
 * @callback WindowLoadCallback
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/load_event load event}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/Image Image() constructor}
 * @see {@link https://web.cse.ohio-state.edu/~shen.94/581/Site/Slides_files/texture.pdf Texture Mapping}
 * @see {@link https://www.evl.uic.edu/pape/data/Earth/ Earth images}
 * @event load
 */
window.addEventListener("load", (event) => {
  image = new Image();

  /**
   * &lt;p>Callback after a new texture {@link image} is loaded.&lt;/p>
   * When called for the first time, it starts the animation.
   * Otherwise, just loads a new texture.
   * @callback ImageLoadCallback
   */
  image.onload = function () {
    // chain the animation or load a new texture
    if (typeof theModel === "undefined") {
      readFileNames
        .then((arr) => {
          if (arr.length > 0) imageFilename = arr.sort();
          setTextures(imageFilename);
          startForReal(image);
        })
        .catch((error) => {
          console.log(`${error}`);
          // don't return anything => execution goes the normal way
          // in case server does not run php
          getTextures(imageFilename);
          startForReal(image);
        });
    } else {
      newTexture(image);
      draw();
    }
  };
  // starts loading the image asynchronously
  image.src = `./textures/${imageFilename[0]}`;
});

/**
 * &lt;p>Sets up all buffers for the given (triangulated) model (shape).&lt;/p>
 *
 * Uses the webgl {@link vertexBuffer vertex buffer},
 * {@link normalBuffer normal buffer}, {@link texCoordBuffer texture buffer}
 * and {@link indexBuffer index buffer}, created in {@link startForReal}.&lt;br>
 * Then, binds each one of them as an array buffer and copies the corresponding shape array data to them.
 *
 * &lt;p>Also, the Euler characteristic for the model is:&lt;/p>
 * &lt;ul>
 *  &lt;li>Ï‡ = 2 âˆ’ 2g âˆ’ b &lt;/li>
 * &lt;/ul>
 * for a surface with g handles and b boundaries.
 *
 * &lt;p>The number of triangles must be even for a valid triangulation of the sphere:&lt;/p>
 * &lt;ul>
 *  &lt;li> V - E + T = 2 (sphere) &lt;/li>
 *  &lt;li> V - E + T = 0 (torus) &lt;/li>
 * &lt;/ul>
 *
 * @param {Object} model model descriptor.
 * @property {modelData} model.shape a &lt;a href="https://en.wikipedia.org/wiki/Boundary_representation">BREP&lt;/a> model
 *                    given as an &lt;a href="https://math.hws.edu/graphicsbook/c3/s4.html">IFS&lt;/a>.
 * @property {Number | null} model.chi=2 model &lt;a href="https://en.wikipedia.org/wiki/Euler_characteristic">Euler Characteristic&lt;/a>.
 * @property {Number} model.poly=0 initial polyhedron for subdivision:&lt;br>
 *     0 - dodecahedron, &lt;br>
 *     1 - icosahedron, &lt;br>
 *     2 - octahedron, &lt;br>
 *     3 - tetrahedron
 * @property {Boolean} model.fix_uv=false whether to change uv texture coordinates.
 * @returns {modelData} shape.
 * @see {@link https://en.wikipedia.org/wiki/Platonic_solid Platonic solid}
 * @see {@link https://ocw.mit.edu/courses/18-965-geometry-of-manifolds-fall-2004/pages/lecture-notes/ Geometry Of Manifolds}
 * @see {@link https://nrich.maths.org/1384 Euler's Formula and Topology}
 * @see {@link https://math.stackexchange.com/questions/3571483/euler-characteristic-of-a-polygon-with-a-hole Euler characteristic of a polygon with a hole}
 *
 */
function createModel({ shape, chi = 2, poly = 0, fix_uv = false }) {
  if (typeof shape === "undefined") {
    setUVfix(true);
    if (poly === 0) {
      shape = new polyhedron(fix_uv, mercator).dodecahedron({
        n: numSubdivisions,
      });
      shape.nfaces = 36;
      maxSubdivisions = limit.dod;
    } else if (poly === 2) {
      shape = new polyhedron(fix_uv, mercator).octahedron({
        n: numSubdivisions,
      });
      shape.nfaces = 8;
      maxSubdivisions = limit.oct;
    } else if (poly === 3) {
      shape = new polyhedron(fix_uv, mercator).tetrahedron({
        n: numSubdivisions,
      });
      shape.nfaces = 4;
      maxSubdivisions = limit.tet;
    } else {
      shape = new polyhedron(fix_uv, mercator).icosahedron({
        n: numSubdivisions,
      });
      shape.nfaces = 20;
      maxSubdivisions = limit.ico;
    }
  } else {
    setUVfix(false);
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, shape.vertexPositions, gl.STATIC_DRAW);

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, shape.vertexNormals, gl.STATIC_DRAW);

  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, shape.vertexTextureCoords, gl.STATIC_DRAW);

  let nv = shape.vertexPositions.length;
  normal = new Float32Array(6 * nv);
  for (var i = 0, k = 0; i &lt; nv; i += 3, k += 6) {
    for (var j = 0; j &lt; 3; j++) {
      normal[j + k] = shape.vertexPositions[i + j];
      normal[j + k + 3] =
        normal[j + k] + (0.1 / mscale) * shape.vertexNormals[i + j];
    }
  }

  // number of faces: ni / 3
  // number of edges: ni
  // number of endpoints: ni * 6
  if (shape.indices) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);

    let ni = shape.indices.length;
    lines = new Float32Array(18 * ni);
    for (i = 0, k = 0; i &lt; ni; i += 3, k += 18) {
      for (j = 0; j &lt; 3; j++) {
        let v1 = shape.vertexPositions[shape.indices[i] * 3 + j];
        let v2 = shape.vertexPositions[shape.indices[i + 1] * 3 + j];
        let v3 = shape.vertexPositions[shape.indices[i + 2] * 3 + j];

        lines[j + k] = v1;
        lines[j + k + 3] = v2;

        lines[j + k + 6] = v2;
        lines[j + k + 9] = v3;

        lines[j + k + 12] = v3;
        lines[j + k + 15] = v1;
      }
    }
  } else {
    let ni = shape.vertexPositions.length;
    lines = new Float32Array(18 * ni);
    for (i = 0, k = 0; i &lt; ni; i += 3, k += 18) {
      for (j = 0; j &lt; 3; j++) {
        let v1 = shape.vertexPositions[i * 3 + j];
        let v2 = shape.vertexPositions[(i + 1) * 3 + j];
        let v3 = shape.vertexPositions[(i + 2) * 3 + j];

        lines[j + k] = v1;
        lines[j + k + 3] = v2;

        lines[j + k + 6] = v2;
        lines[j + k + 9] = v3;

        lines[j + k + 12] = v3;
        lines[j + k + 15] = v1;
      }
    }
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, lines, gl.STATIC_DRAW);

  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, normal, gl.STATIC_DRAW);

  let obj = document.getElementById("object");

  let faces = shape.indices
    ? shape.indices.length / 3
    : shape.vertexPositions.length / 9;
  let edges = (faces * 3) / 2;
  let vertices = faces / 2 + chi;

  if (chi === null) {
    edges = `${edges}??`;
    vertices = `${vertices}??`;
  }
  obj.innerHTML = `&lt;b>Object &lt;/b>(${faces} triangles, ${edges} edges, ${vertices} vertices):`;

  return shape;
}

/**
 * Returns whether a given value is a power of two.
 * @param {Number} value number to check.
 * @returns {Boolean} true if value is a power of two: value = 2&lt;sup>n&lt;/sup>
 */
function isPowerOf2(value) {
  return (value &amp; (value - 1)) === 0;
}

/**
 * &lt;p>Creates a textured model and triggers the animation.&lt;/p>
 *
 * Basically this function does setup that "should" only have to be done once,&lt;br>
 * while {@link draw draw()} does things that have to be repeated each time the canvas is
 * redrawn.
 * @param {HTMLImageElement} image texture.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/generateMipmap
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
 * @see {@link https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences WebGL and OpenGL Differences}
 * @see {@link https://learnopengl.com/Getting-started/Textures Textures}
 * @see {@link https://artincontext.org/shades-of-teal/ 38 Shades of Teal Color}
 * @see {@link https://www.khronos.org/opengl/wiki/Common_Mistakes Common Mistakes}
 * @see {@link https://www.youtube.com/watch?v=qMCOX3m-R28 What are Mipmaps?}
 */
function startForReal(image) {
  console.log("Started...");

  // retrieve &lt;canvas> element
  var canvas = document.getElementById("theCanvas");

  /**
   * &lt;p>Appends an event listener for events whose type attribute value is keydown.&lt;br>
   * The {@link handleKeyPress callback} argument sets the callback that will be invoked when
   * the event is dispatched.&lt;/p>
   *
   * @event keydown
   */
  window.addEventListener("keydown", (event) => {
    if (
      ["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(
        event.code,
      ) > -1
    ) {
      event.preventDefault();
    }
    handleKeyPress(event);
  });

  gl = canvas.getContext("webgl2");
  if (!gl) {
    console.log("Failed to get the rendering context for WebGL2");
    gl = canvas.getContext("webgl");
    if (!gl) {
      console.log("Failed to get the rendering context for WebGL");
      return;
    }
  }

  // load and compile the shader pair, using utility from the teal book
  var vshaderSource = document.getElementById("vertexColorShader").textContent;
  var fshaderSource = document.getElementById(
    "fragmentColorShader",
  ).textContent;
  if (!initShaders(gl, vshaderSource, fshaderSource)) {
    console.log("Failed to initialize shaders.");
    return;
  }
  colorShader = gl.program;
  gl.useProgram(null);

  // load and compile the shader pair, using utility from the teal book
  var vshaderSource = document.getElementById(
    "vertexLightingShader",
  ).textContent;
  var fshaderSource = document.getElementById(
    "fragmentLightingShader",
  ).textContent;
  if (!initShaders(gl, vshaderSource, fshaderSource)) {
    console.log("Failed to initialize shaders.");
    return;
  }
  lightingShader = gl.program;
  gl.useProgram(null);

  // buffer for vertex positions for triangles
  vertexBuffer = gl.createBuffer();
  indexBuffer = gl.createBuffer();
  if (!vertexBuffer) {
    console.log("Failed to create the buffer object");
    return null;
  }

  // buffer for vertex normals
  vertexNormalBuffer = gl.createBuffer();
  if (!vertexNormalBuffer) {
    console.log("Failed to create the buffer object");
    return null;
  }

  // buffer for texture coords
  texCoordBuffer = gl.createBuffer();
  if (!texCoordBuffer) {
    console.log("Failed to create the buffer object");
    return null;
  }

  // axes
  axisBuffer = gl.createBuffer();
  normalBuffer = gl.createBuffer();
  lineBuffer = gl.createBuffer();
  parallelBuffer = gl.createBuffer();
  meridianBuffer = gl.createBuffer();
  if (!axisBuffer) {
    console.log("Failed to create the buffer object");
    return;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, axisVertices, gl.STATIC_DRAW);

  // buffer for axis colors
  axisColorBuffer = gl.createBuffer();
  if (!axisColorBuffer) {
    console.log("Failed to create the buffer object");
    return;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, axisColorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, axisColors, gl.STATIC_DRAW);

  let equatorVertices = pointsOnParallel(
    nsegments,
    gpsCoordinates[currentLocation].latitude,
  );
  gl.bindBuffer(gl.ARRAY_BUFFER, parallelBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, equatorVertices, gl.STATIC_DRAW);

  let meridianVertices = pointsOnMeridian(
    nsegments,
    gpsCoordinates[currentLocation].longitude,
  );
  gl.bindBuffer(gl.ARRAY_BUFFER, meridianBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, meridianVertices, gl.STATIC_DRAW);

  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // ask the GPU to create a texture object
  textureHandle = gl.createTexture();

  // choose a texture unit to use during setup, defaults to zero
  // (can use a different one when drawing)
  // max value is MAX_COMBINED_TEXTURE_IMAGE_UNITS
  gl.activeTexture(gl.TEXTURE0);

  newTexture(image);

  // specify a teal like fill color for clearing the framebuffer
  gl.clearColor(0.0, 0.4, 0.4, 1.0);

  gl.enable(gl.DEPTH_TEST);
  if (culling) gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);
  // normals pointing outward
  gl.frontFace(gl.CCW);

  rotator = new SimpleRotator(canvas, animate);
  rotator.setViewMatrix(modelMatrix);
  rotator.setViewDistance(0);

  $('label[for="equator"]').html(currentLocation);

  selectModel();

  // start drawing!
  animate();
}

/**
 * &lt;p>A closure holding the type of the model.&lt;/p>
 * {@link https://vcg.isti.cnr.it/Publications/2012/Tar12/jgt_tarini.pdf Tarini's}
 * method does not work for objects like polyhedra.&lt;br>
 * It was meant for objects whose texture coordinates were set by using
 * {@link https://docs.blender.org/manual/en/2.79/editors/uv_image/uv/editing/unwrapping/mapping_types.html cylindrical or spherical uv-mappings}.&lt;br>
 * For instance, a cube's face texture coordinates span from 0 to 1.
 * &lt;p>Therefore, we only use it for subdivision spheres.&lt;/p>
 * @return {UVfix}
 * @function
 */
const setUVfix = (() => {
  let subdivisionModel = false;

  /**
   * Callback to decide whether to fix UV coordinates, based on
   * the model type (subdivision or not), and if it is a textured
   * model or not.
   * @param {Boolean} subModel &lt;br>
   *   true: subdividion model, &lt;br>
   *   false: normal model, &lt;br>
   *   undefined: not known. Use the type saved in the closure.
   * @callback UVfix
   */
  return (subModel) => {
    gl.useProgram(lightingShader);
    let u_fix = gl.getUniformLocation(lightingShader, "u_fix");
    let texCoordIndex = gl.getAttribLocation(lightingShader, "a_TexCoord");

    if (texCoordIndex &lt; 0) {
      // no texture
      gl.uniform1i(u_fix, fixuv);
    } else if (subModel == undefined) {
      if (subdivisionModel) {
        gl.uniform1i(u_fix, fixuv &amp;&amp; numSubdivisions > 0);
      } else {
        gl.uniform1i(u_fix, false);
      }
    } else if (subModel) {
      subdivisionModel = true;
      gl.uniform1i(u_fix, fixuv &amp;&amp; numSubdivisions > 0);
    } else {
      subdivisionModel = false;
      gl.uniform1i(u_fix, false);
    }
    gl.useProgram(null);
  };
})();

/**
 * &lt;p>Creates a new texture from an image.&lt;/p>
 * Uses the {@link lightingShader}.
 * @param {HTMLImageElement} image texture.
 * @see {@link https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html WebGL Textures}
 * @see {@link https://jameshfisher.com/2020/10/22/why-is-my-webgl-texture-upside-down/ Why is my WebGL texture upside-down?}
 * @see {@link https://registry.khronos.org/webgl/specs/latest/2.0/#4.1.3 Non-Power-of-Two Texture Access}
 * @see {@link https://www.youtube.com/watch?v=qMCOX3m-R28 What are Mipmaps?}
 */
function newTexture(image) {
  gl.useProgram(lightingShader);
  let imgSize = document.getElementById("size");
  imgSize.innerHTML = `${imageFilename[textureCnt]} (${image.width} x ${image.height})`;
  document.getElementById("textimg").src = image.src;
  document.getElementById("textures").value = String(textureCnt);

  // bind the texture
  gl.bindTexture(gl.TEXTURE_2D, textureHandle);

  /*
   * (0,0) in the image coordinate system is the top left corner,
   * and the (0,0) in the texture coordinate system is bottom left.
   * Therefore, load the image bytes to the currently bound texture,
   * flipping the vertical.
   */
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  if (
    typeof WebGL2RenderingContext !== "undefined" ||
    (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height))
  ) {
    setUVfix();

    // texture parameters are stored with the texture
    gl.generateMipmap(gl.TEXTURE_2D);
    // texture magnification filter - default is gl.LINEAR (blurred)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

    // reset defaults

    // texture minification filter
    gl.texParameteri(
      gl.TEXTURE_2D,
      gl.TEXTURE_MIN_FILTER,
      gl.NEAREST_MIPMAP_LINEAR,
    );

    // wrapping function for texture coordinate s
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);

    // wrapping function for texture coordinate t
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  } else {
    // NPOT
    setUVfix(false);

    // texture minification filter
    gl.texParameteri(
      gl.TEXTURE_2D,
      gl.TEXTURE_MIN_FILTER,
      gl.LINEAR, // default is gl.NEAREST_MIPMAP_LINEAR
    );

    // wrapping function for texture coordinate s (default is gl.REPEAT)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);

    // wrapping function for texture coordinate t (default is gl.REPEAT)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  }
  gl.useProgram(null);
}

/**
 * &lt;p>Define an {@link frame animation} loop.&lt;/p>
 * Step 0.5Â° â‡’ 60 fps = 30Â°/s â‡’ 360Â° in 12s
 * @see {@link https://dominicplein.medium.com/extrinsic-intrinsic-rotation-do-i-multiply-from-right-or-left-357c38c1abfd Extrinsic &amp; intrinsic rotation}
 */
var animate = (() => {
  // increase the rotation by some amount, depending on the axis chosen
  const increment = (0.5 * Math.PI) / 180;
  /** @type {Number} */
  var requestID = 0;
  const rotMatrix = {
    x: mat4.fromXRotation([], increment),
    y: mat4.fromYRotation([], increment),
    z: mat4.fromZRotation([], increment),
  };

  /**
   * Callback to keep drawing frames.
   * @callback frame
   * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
   */
  return () => {
    draw();
    if (requestID != 0) {
      cancelAnimationFrame(requestID);
      requestID = 0;
    }
    if (!selector.paused) {
      if (selector.intrinsic) {
        // intrinsic rotation - multiply on the right
        mat4.multiply(modelMatrix, modelMatrix, rotMatrix[axis]);
      } else {
        // extrinsic rotation - multiply on the left
        mat4.multiply(modelMatrix, rotMatrix[axis], modelMatrix);
      }
      rotator.setViewMatrix(modelMatrix);
      // request that the browser calls animate() again "as soon as it can"
      requestID = requestAnimationFrame(animate);
    } else {
      modelMatrix = rotator.getViewMatrix();
    }
  };
})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glMatrix.html">glMatrix</a></li><li><a href="module-mat2.html">mat2</a></li><li><a href="module-mat2d.html">mat2d</a></li><li><a href="module-mat3.html">mat3</a></li><li><a href="module-mat4.html">mat4</a></li><li><a href="module-quat.html">quat</a></li><li><a href="module-quat2.html">quat2</a></li><li><a href="module-vec2.html">vec2</a></li><li><a href="module-vec3.html">vec3</a></li><li><a href="module-vec4.html">vec4</a></li></ul><h3>Externals</h3><ul><li><a href="external-THREE.html">THREE</a></li></ul><h3>Classes</h3><ul><li><a href="SimpleRotator.html">SimpleRotator</a></li><li><a href="TeapotGeometry.html">TeapotGeometry</a></li><li><a href="external-THREE.BufferGeometry.html">BufferGeometry</a></li><li><a href="polyhedron.html">polyhedron</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:change-executedwhentheaxescheckboxischeckedorunchecked.">change - executed when the axes checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhenthecullcheckboxischeckedorunchecked.">change - executed when the cull checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhentheequatorcheckboxischeckedorunchecked.">change - executed when the equator checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhenthefix_uvcheckboxischeckedorunchecked.">change - executed when the fix_uv checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhenthemercatorcheckboxischeckedorunchecked.">change - executed when the mercator checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhenthemeshcheckboxischeckedorunchecked.">change - executed when the mesh checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhenthemodeinputradioischecked(butnotwhenunchecked).">change - executed when the mode input radio is checked (but not when unchecked).</a></li><li><a href="global.html#event:change-executedwhenthemodels&lt;select&gt;ischanged.">change - executed when the models &lt;select&gt; is changed.</a></li><li><a href="global.html#event:change-executedwhentherotinputradioischecked(butnotwhenunchecked).">change - executed when the rot input radio is checked (but not when unchecked).</a></li><li><a href="global.html#event:change-executedwhenthetexturecheckboxischeckedorunchecked.">change - executed when the texture checkbox is checked or unchecked.</a></li><li><a href="global.html#event:change-executedwhenthetextures&lt;select&gt;ischanged.">change - executed when the textures &lt;select&gt; is changed.</a></li><li><a href="global.html#event:keydown">keydown</a></li><li><a href="global.html#event:load">load</a></li></ul><h3>Global</h3><ul><li><a href="global.html#animate">animate</a></li><li><a href="global.html#axis">axis</a></li><li><a href="global.html#axisBuffer">axisBuffer</a></li><li><a href="global.html#axisColorBuffer">axisColorBuffer</a></li><li><a href="global.html#axisColors">axisColors</a></li><li><a href="global.html#axisVertices">axisVertices</a></li><li><a href="global.html#cartesian2Spherical">cartesian2Spherical</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#colorShader">colorShader</a></li><li><a href="global.html#createEvent">createEvent</a></li><li><a href="global.html#createModel">createModel</a></li><li><a href="global.html#createProgram">createProgram</a></li><li><a href="global.html#cube">cube</a></li><li><a href="global.html#culling">culling</a></li><li><a href="global.html#currentLocation">currentLocation</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawAxes">drawAxes</a></li><li><a href="global.html#drawLines">drawLines</a></li><li><a href="global.html#drawParallel">drawParallel</a></li><li><a href="global.html#drawTexture">drawTexture</a></li><li><a href="global.html#eye">eye</a></li><li><a href="global.html#fixuv">fixuv</a></li><li><a href="global.html#getChar">getChar</a></li><li><a href="global.html#getModelData">getModelData</a></li><li><a href="global.html#getModelMatrix">getModelMatrix</a></li><li><a href="global.html#getTextures">getTextures</a></li><li><a href="global.html#getWebGLContext">getWebGLContext</a></li><li><a href="global.html#gl">gl</a></li><li><a href="global.html#gpsCoordinates">gpsCoordinates</a></li><li><a href="global.html#handleKeyPress">handleKeyPress</a></li><li><a href="global.html#image">image</a></li><li><a href="global.html#imageFilename">imageFilename</a></li><li><a href="global.html#indexBuffer">indexBuffer</a></li><li><a href="global.html#initShaders">initShaders</a></li><li><a href="global.html#initialOcta">initialOcta</a></li><li><a href="global.html#initialTet">initialTet</a></li><li><a href="global.html#isPowerOf2">isPowerOf2</a></li><li><a href="global.html#lightPropElements">lightPropElements</a></li><li><a href="global.html#lightingShader">lightingShader</a></li><li><a href="global.html#limit">limit</a></li><li><a href="global.html#lineBuffer">lineBuffer</a></li><li><a href="global.html#lines">lines</a></li><li><a href="global.html#loadShader">loadShader</a></li><li><a href="global.html#makeNormalMatrixElements">makeNormalMatrixElements</a></li><li><a href="global.html#mat3">mat3</a></li><li><a href="global.html#mat4">mat4</a></li><li><a href="global.html#matPropElements">matPropElements</a></li><li><a href="global.html#maxSubdivisions">maxSubdivisions</a></li><li><a href="global.html#mercator">mercator</a></li><li><a href="global.html#mercator2Spherical">mercator2Spherical</a></li><li><a href="global.html#meridianBuffer">meridianBuffer</a></li><li><a href="global.html#modelMatrix">modelMatrix</a></li><li><a href="global.html#mscale">mscale</a></li><li><a href="global.html#newTexture">newTexture</a></li><li><a href="global.html#nextLevel">nextLevel</a></li><li><a href="global.html#nextTexture">nextTexture</a></li><li><a href="global.html#normal">normal</a></li><li><a href="global.html#normalBuffer">normalBuffer</a></li><li><a href="global.html#nsegments">nsegments</a></li><li><a href="global.html#numSubdivisions">numSubdivisions</a></li><li><a href="global.html#parallelBuffer">parallelBuffer</a></li><li><a href="global.html#pointsOnAntiMeridian">pointsOnAntiMeridian</a></li><li><a href="global.html#pointsOnEquator">pointsOnEquator</a></li><li><a href="global.html#pointsOnMeridian">pointsOnMeridian</a></li><li><a href="global.html#pointsOnParallel">pointsOnParallel</a></li><li><a href="global.html#pointsOnPrimeMeridian">pointsOnPrimeMeridian</a></li><li><a href="global.html#previousLevel">previousLevel</a></li><li><a href="global.html#previousTexture">previousTexture</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#radians">radians</a></li><li><a href="global.html#readFileNames">readFileNames</a></li><li><a href="global.html#ring">ring</a></li><li><a href="global.html#rotator">rotator</a></li><li><a href="global.html#selectModel">selectModel</a></li><li><a href="global.html#selectTexture">selectTexture</a></li><li><a href="global.html#selector">selector</a></li><li><a href="global.html#setTextures">setTextures</a></li><li><a href="global.html#setUVfix">setUVfix</a></li><li><a href="global.html#shininess">shininess</a></li><li><a href="global.html#spherical2Cartesian">spherical2Cartesian</a></li><li><a href="global.html#spherical2Mercator">spherical2Mercator</a></li><li><a href="global.html#startForReal">startForReal</a></li><li><a href="global.html#teapotModel">teapotModel</a></li><li><a href="global.html#texCoordBuffer">texCoordBuffer</a></li><li><a href="global.html#textureCnt">textureCnt</a></li><li><a href="global.html#textureHandle">textureHandle</a></li><li><a href="global.html#theModel">theModel</a></li><li><a href="global.html#uvCone">uvCone</a></li><li><a href="global.html#uvCylinder">uvCylinder</a></li><li><a href="global.html#uvSphere">uvSphere</a></li><li><a href="global.html#uvTorus">uvTorus</a></li><li><a href="global.html#vec3">vec3</a></li><li><a href="global.html#vertexBuffer">vertexBuffer</a></li><li><a href="global.html#vertexNormalBuffer">vertexNormalBuffer</a></li><li><a href="global.html#viewMatrix">viewMatrix</a></li><li><a href="global.html#zoomIn">zoomIn</a></li><li><a href="global.html#zoomOut">zoomOut</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Wed May 08 2024 20:08:20 GMT-0300 (Brasilia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
