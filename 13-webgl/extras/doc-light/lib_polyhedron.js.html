<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/polyhedron.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/polyhedron.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** @module polyhedron */

/**
 *  @file
 *
 *  Summary.
 *
 * &lt;p>Creates the model of a sphere by continuously subdividing an initial
 * {@link https://en.wikipedia.org/wiki/Regular_polyhedron convex regular polyhedron}.&lt;/p>
 *
 * The algorithm starts with just four, six, twenty, or twelve points, corresponding
 * to a {@link https://www.brainsofsteel.co.uk/post/how-to-make-a-tetrahedron tetrahedron},
 *      {@link https://www.youtube.com/watch?v=47yZf6GHqzg octahedron},
 *      {@link https://www.polyhedra.net/en/model.php?name-en=dodecahedron dodecahedron}, or
 *      {@link https://www.mathhappens.org/take-and-make-icosahedron-from-golden-rectangles/ icosahedron},
 * inscribed in the unit sphere,
 * and recursively subdivides each triangle by inserting a new vertex
 * at the midpoint of its three edges,
 * which is then projected onto the surface of the sphere.
 *
 *  @author Paulo Roma Cavalcanti
 *  @since 21/11/2016
 *  @see &lt;a href="/cwdc/13-webgl/lib/polyhedron.js">source&lt;/a>
 *  @see {@link https://www.cs.unm.edu/~angel/BOOK/INTERACTIVE_COMPUTER_GRAPHICS/SIXTH_EDITION/CODE/WebGL/7E/06 Angel's code}
 *  @see &lt;a href="https://www.britannica.com/science/Platonic-solid">Platonic solid&lt;/a>
 *  @see &lt;a href="https://www.mathsisfun.com/geometry/platonic-solids-why-five.html">Platonic Solids - Why Five?&lt;/a>
 *  @see &lt;a href="https://users.monash.edu.au/~normd/documents/MATH-348-lecture-32.pdf">Platonic Solids and Beyond&lt;/a>
 *  @see &lt;img src="/cwdc/13-webgl/lib/tets/tet1.png" width="256"> &lt;img src="/cwdc/13-webgl/lib/tets/tet2.png" width="256">
 *  @see &lt;img src="/cwdc/13-webgl/lib/tets/tet3.png" width="256"> &lt;img src="/cwdc/13-webgl/lib/tets/tet4.png" width="256">
 *  @see &lt;img src="/cwdc/13-webgl/lib/tets/octa1.png" width="256"> &lt;img src="/cwdc/13-webgl/lib/tets/octa2.png" width="256">
 *  @see &lt;img src="/cwdc/13-webgl/lib/tets/octa3.png" width="256"> &lt;img src="/cwdc/13-webgl/lib/tets/octa4.png" width="256">
 */

"use strict";

// import * as THREE from "three";
import * as THREE from "/cwdc/13-webgl/lib/three.module.js";
import { vec3 } from "/cwdc/13-webgl/lib/gl-matrix/dist/esm/index.js";

/**
 * An object containing raw data for
 * vertices, normal vectors, texture coordinates, mercator coordinates and indices.
 * &lt;p>{@link https://threejs.org/docs/#api/en/geometries/PolyhedronGeometry Polyhedra} have no index.&lt;/p>
 * @typedef {Object} polyData
 * @property {Float32Array} vertexPositions vertex coordinates.
 * @property {Float32Array} vertexNormals vertex normals.
 * @property {Float32Array} vertexTextureCoords texture coordinates.
 * @property {Float32Array} vertexMercatorCoords mercator texture coordinates.
 * @property {Uint16Array} indices index array.
 * @property {String} name polyhedron name.
 * @property {Number} nfaces initial number of triangles.
 * @property {Number} maxNumSubdivisions maximum number of subdivisions.
 * @property {Function} ntri return the number of triangles given the level of detail.
 * @property {Function} level return the level of detail given the number of triangles.
 */

/**
 * gl-matrix {@link https://glmatrix.net/docs/module-vec3.html 3 Dimensional Vector}.
 * @name vec3
 * @type {glMatrix.vec3}
 */

/**
 * &lt;p>Four points of a {@link https://www.brainsofsteel.co.uk/post/how-to-make-a-tetrahedron tetrahedron}
 * inscribed in the unit sphere, in three different vertex arrangements.&lt;/p>
 *
 * Radius of circunsphere:
 * &lt;ul>
 *  &lt;li>R = √6 a/4 = 1&lt;/li>
 * &lt;/ul>
 *
 * Radius of circuncircle:
 * &lt;ul>
 *  &lt;li>r = a/√3 = 2/3 √6 / √3 = 2/3 √2 = √(8/9) = 0.9428090415820634&lt;/li>
 * &lt;/ul>
 *
 * Edge length:
 * &lt;ul>
 *  &lt;li>a = 4R / √6 = 2/3 √6 = 1.6329931618554523&lt;/li>
 * &lt;/ul>
 *
 * Vertex coordinates:
 * &lt;ul>
 *  &lt;li>x = r sin(π/6) = √(2/9) = 0.4714045207910317&lt;/li>
 *  &lt;li>y = r cos(π/6) = √(2/3) = 0.816496580927726&lt;/li>
 *  &lt;li>z = 1/3 = 0.3333333333333333 (24/9 = 8/9 + (z+1)²)&lt;/li>
 * &lt;/ul>
 *
 * Four vertices, lower face parallel to the xy plane:
 * &lt;ul>
 *  &lt;li>(r, 0, -z)&lt;/li>
 *  &lt;li>(-x, y, -z)&lt;/li>
 *  &lt;li>(-x, -y, -z)&lt;/li>
 *  &lt;li>(0, 0, 1)&lt;/li>
 * &lt;/ul>
 * Alternatively, higher face parallel to the xy plane:
 * &lt;ul>
 *  &lt;li>(0, r, z)&lt;/li>
 *  &lt;li>(y, -x, z)&lt;/li>
 *  &lt;li>(-y, -x, z)&lt;/li>
 *  &lt;li>(0, 0, -1)&lt;/li>
 * &lt;/ul>
 * Embedded inside a cube:
 * &lt;ul>
 *  &lt;li>(1/√3, 1/√3, 1/√3)&lt;/li>
 *  &lt;li>(-1/√3, -1/√3, 1/√3)&lt;/li>
 *  &lt;li>(-1/√3, 1/√3, -1/√3)&lt;/li>
 *  &lt;li>(1/√3, -1/√3, -1/√3)&lt;/li>
 * &lt;/ul>
 * @type {Array&lt;vec3>}
 * @see {@link https://en.wikipedia.org/wiki/Tetrahedron Tetrahedron}
 * @see {@link https://en.wikipedia.org/wiki/Equilateral_triangle Equilateral triangle}
 * @see &lt;figure>
 *      &lt;img src="../images/Tetrahedron.svg" width="128">
 *      &lt;img src="../images/tet.png" width="164">
 *      &lt;figcaption>
 *        Lower face parallel to the xy plane.
 *      &lt;/figcaption>
 *      &lt;img src="../images/Tetraeder_animation_with_cube.gif" width="128">
 *      &lt;figcaption>
 *        Embedded in a cube.
 *      &lt;/figcaption>
 *      &lt;/figure>
 */
const initialTet = (() => {
  const r = Math.sqrt(8 / 9);
  const x = r * 0.5; // r * sin(Math.PI/6)
  const y = Math.sqrt(2 / 3); // r * cos(Math.PI/6)
  const z = 1 / 3;
  const d = 1 / Math.sqrt(3);
  return {
    normal: [
      vec3.fromValues(0, r, z),
      vec3.fromValues(y, -x, z),
      vec3.fromValues(-y, -x, z),
      vec3.fromValues(0, 0, -1),
    ],
    alternative: [
      vec3.fromValues(r, 0, -z),
      vec3.fromValues(-x, y, -z),
      vec3.fromValues(-x, -y, -z),
      vec3.fromValues(0, 0, 1),
    ],
    cube: [
      vec3.fromValues(d, d, d),
      vec3.fromValues(-d, -d, d),
      vec3.fromValues(-d, d, -d),
      vec3.fromValues(d, -d, -d),
    ],
  };
})();

/**
 * &lt;p>Six points of an {@link https://www.youtube.com/watch?v=47yZf6GHqzg octahedron}
 * inscribed in the unit sphere.&lt;/p>
 *
 * Radius of circunsphere:
 * &lt;ul>
 *  &lt;li>R = √2/2 a = 1&lt;/li>
 * &lt;/ul>
 *
 * Edge length:
 * &lt;ul>
 *  &lt;li>a = 2R / √2 = 1.414213562373095&lt;/li>
 * &lt;/ul>
 *
 * Six vertices:
 * &lt;ul>
 *  &lt;li>(±1, 0, 0)&lt;/li>
 *  &lt;li>(0, ±1, 0)&lt;/li>
 *  &lt;li>(0, 0, ±1)&lt;/li>
 * &lt;/ul>
 *
 * @type {Array&lt;vec3>}
 * @see {@link https://en.wikipedia.org/wiki/Octahedron Octahedron}
 * @see &lt;img src="../images/Octahedron.gif" width="256">
 */
const initialOcta = [
  vec3.fromValues(0.0, 0.0, 1.0),
  vec3.fromValues(0.0, 0.0, -1.0),
  vec3.fromValues(0.0, 1.0, 0.0),
  vec3.fromValues(0.0, -1.0, 0.0),
  vec3.fromValues(1.0, 0.0, 0.0),
  vec3.fromValues(-1.0, 0.0, 0.0),
];

/**
 * &lt;p>Twelve points of an {@link https://www.mathhappens.org/take-and-make-icosahedron-from-golden-rectangles/ icosahedron}
 * inscribed in the unit sphere.&lt;/p>
 *
 * Golden Ratio:
 * &lt;ul>
 *  &lt;li>Φ = (√5+1)/2 = 1.618033988749895 &lt;/li>
 * &lt;/ul>
 *
 * Radius of circunsphere:
 * &lt;ul>
 *  &lt;li>R = √(Φ² + 1)/2 a = 1&lt;/li>
 *  &lt;li>r = √(Φ² + 1) = 1.902113032590307 (a=2)&lt;/li>
 * &lt;/ul>
 *
 * Edge length:
 * &lt;ul>
 *  &lt;li>a = 2R / √(Φ² + 1) = 0.7639320225002103&lt;/li>
 * &lt;/ul>
 *
 * Vertex Coordinates:
 * &lt;ul>
 *  &lt;li>Φ / √(Φ² + 1)) = 0.85065080835204&lt;/li>
 *  &lt;li>1 / √(Φ² + 1) = 0.5257311121191336&lt;/li>
 * &lt;/ul>
 * Twelve vertices:
 * &lt;ul>
 *  &lt;li>(0, ±1/r, ±Φ/r) &lt;/li>
 *  &lt;li>(±1/r, ±Φ/r, 0) &lt;/li>
 *  &lt;li>(±Φ/r, 0, ±1/r) &lt;/li>
 * &lt;/ul>
 *
 * @type {Array&lt;vec3>}
 * @see {@link https://en.wikipedia.org/wiki/Icosahedron Icosahedron}
 * @see {@link https://en.wikipedia.org/wiki/Regular_icosahedron Regular icosahedron}
 * @see &lt;img src="../images/Icosahedron-golden-rectangles.svg" width="256">
 */
const initialIco = (() => {
  const a = (Math.sqrt(5) + 1) / 2;
  const r = Math.sqrt(a * a + 1);
  const b = 1 / r;
  const c = a / r;
  return [
    vec3.fromValues(0, -b, c),

    vec3.fromValues(c, 0, b),
    vec3.fromValues(c, 0, -b),
    vec3.fromValues(-c, 0, -b),
    vec3.fromValues(-c, 0, b),

    vec3.fromValues(-b, c, 0),
    vec3.fromValues(b, c, 0),
    vec3.fromValues(b, -c, 0),
    vec3.fromValues(-b, -c, 0),

    vec3.fromValues(0, -b, -c),
    vec3.fromValues(0, b, -c),
    vec3.fromValues(0, b, c),
  ];
})();

/**
 * &lt;p>Twenty points of a {@link https://www.polyhedra.net/en/model.php?name-en=dodecahedron dodecahedron}
 * inscribed in the unit sphere.&lt;/p>
 * Golden Ratio:
 * &lt;ul>
 *  &lt;li>Φ = (√5+1)/2 = 1.618033988749895 &lt;/li>
 *  &lt;ki>2/Φ = √5 - 1 = 1.2360679774997898&lt;/li>
 * &lt;/ul>
 * Radius of circunscribed sphere:
 * &lt;ul>
 *  &lt;li>R = √3 Φ/2 a = 1&lt;/li>
 * &lt;/ul>
 * Edge length:
 * &lt;ul>
 *  &lt;li>a = 4R / ((√5 + 1)√3) = 2/Φ R/√3 = R (√5 - 1) / √3 = 0.71364417954618&lt;/li>
 * &lt;/ul>
 *
 * Vertex coordinates:
 * &lt;ul>
 *  &lt;li>1/√3 = 0.5773502691896258&lt;/li>
 *  &lt;li>1 / Φ√3 = (√5-1) / (2√3) = 0.35682208977309&lt;/li>
 *  &lt;li>Φ / √3 = (√5+1) / (2√3) = 0.9341723589627158&lt;/li>
 * &lt;/ul>
 *
 * The eight vertices of a cube:
 * &lt;ul>
 *  &lt;li>(±1/√3, ±1/√3, ±1/√3)&lt;/li>
 * &lt;/ul>
 * The coordinates of the 12 additional vertices:
 * &lt;ul>
 *  &lt;li>(0, ±(Φ / √3), ±(1 / Φ√3)) &lt;/li>
 *  &lt;li>(±(1 / Φ√3), 0, ±(Φ / √3)) &lt;/li>
 *  &lt;li>(±(Φ / √3), ±(1 / Φ√3), 0) &lt;/li>
 * &lt;/ul>
 * @type {Array&lt;vec3>}
 * @see {@link https://en.wikipedia.org/wiki/Dodecahedron Dodecahedron}
 * @see {@link https://en.wikipedia.org/wiki/Regular_dodecahedron Regular dodecahedron}
 * @see {@link https://www.scientificamerican.com/article/why-did-ancient-romans-make-this-baffling-metal-dodecahedron/ Why Did Ancient Romans Make this Baffling Metal Dodecahedron?}
 * @see &lt;img src="../images/dodecahedron.png" width="256">
 * @see &lt;iframe title="Cube in a Dodecahedron" src="/cwdc/13-webgl/examples/three/content/stl.html" style="transform: scale(0.85); width: 380px; height: 380px">&lt;/iframe>
 * @see {@link https://www.thingiverse.com/thing:3279291 Cube in a Dodecahedron}
 */
const initialDod = (() => {
  const a = 1 / Math.sqrt(3);
  const b = (Math.sqrt(5) - 1) * 0.5 * a;
  const c = (Math.sqrt(5) + 1) * 0.5 * a;
  return [
    vec3.fromValues(-b, 0, c),
    vec3.fromValues(b, 0, c),
    vec3.fromValues(a, a, a),
    vec3.fromValues(0, c, b),
    vec3.fromValues(-a, a, a),
    vec3.fromValues(-a, -a, a),
    vec3.fromValues(0, -c, b),
    vec3.fromValues(a, -a, a),
    vec3.fromValues(c, -b, 0),
    vec3.fromValues(c, b, 0),
    vec3.fromValues(0, -c, -b),
    vec3.fromValues(a, -a, -a),
    vec3.fromValues(a, a, -a),
    vec3.fromValues(0, c, -b),
    vec3.fromValues(-a, -a, -a),
    vec3.fromValues(-b, 0, -c),
    vec3.fromValues(b, 0, -c),
    vec3.fromValues(-c, -b, 0),
    vec3.fromValues(-c, b, 0),
    vec3.fromValues(-a, a, -a),
  ];
})();

/**
 * Maximum subdivision level without overflowing any buffer (16 bits - 65536).
 * @type {Object&lt;{tet:Number, oct:Number, dod:Number, ico: Number}>}
 */
export const limit = {
  tet_hws: Math.floor(Math.log(65536 / (4 * 3)) / Math.log(4)),
  oct_hws: Math.floor(Math.log(65536 / (8 * 3)) / Math.log(4)),
  ico_hws: Math.floor(Math.log(65536 / (20 * 3)) / Math.log(4)),
  dod_hws: Math.floor(Math.log(65536 / (36 * 3)) / Math.log(4)),
  tet: 24,
  oct: 20,
  dod: 12,
  ico: 16,
};

/**
 * Constrain a value to lie between two further values.
 * @param {Number} x value.
 * @param {Number} min minimum value.
 * @param {Number} max maximum value.
 * @return {Number} min ≤ x ≤ max.
 * @function
 */
export const clamp = (x, min, max) => Math.min(Math.max(min, x), max);

/**
 * Convert degrees to radians.
 * @param {Number} deg angle in degrees.
 * @returns {Number} angle in radians.
 * @function
 */
export const radians = (deg) => (deg * Math.PI) / 180;

/**
 * Default number of segments (points - 1) for drawing a meridian or parallel.
 * @type {Number}
 */
export const nsegments = 36;

/**
 * &lt;p>Return a pair of spherical coordinates, in the range [0,1],
 * corresponding to a point p onto the unit sphere.&lt;/p>
 *
 * The forward projection transforms spherical coordinates into planar coordinates:
 * &lt;ul>
 * &lt;li>if point p is plotted on a plane, we have the
 * {@link https://docs.qgis.org/3.4/en/docs/gentle_gis_introduction/coordinate_reference_systems.html &lt;i>plate carrée&lt;/i> projection},
 * a special case of the equirectangular projection.&lt;/li>
 * &lt;li>this projection maps x to be the value of the longitude and
 * y to be the value of the latitude.&lt;/li>
 * &lt;/ul>
 *
 * &lt;p>The singularity of the mapping (parameterization) is at φ = 0 (y = -r) and φ = π (y = r):&lt;/p>
 * &lt;ul>
 *   &lt;li>In this case, an entire line at the top (or bottom) boundary of the texture is mapped onto a single point.&lt;/li>
 *   &lt;li> In {@link https://en.wikipedia.org/wiki/Geographic_coordinate_system geographic coordinate system},
 *   φ is measured from the positive y axis (North), not the z axis, as it is usual in math books.
 *   &lt;li>Therefore, we will use North-Counterclockwise Convention.&lt;/li>
 *   &lt;li>The 'clockwise from north' convention is used in navigation and mapping.&lt;/li>
 *   &lt;li>________________________________________________&lt;/li>
 *   &lt;li> atan2(y, x) (East-Counterclockwise Convention)&lt;/li>
 *   &lt;li> atan2(x, y) (North-Clockwise Convention)&lt;/li>
 *   &lt;li> atan2(-x,-y) (South-Clockwise Convention)&lt;/li>
 *   &lt;li>________________________________________________&lt;/li>
 *   &lt;li> cos(φ-90) = sin(φ)&lt;/li>
 *   &lt;li> sin(φ-90) = -cos(φ)&lt;/li>
 *   &lt;li> x = r cos(θ) sin(φ) &lt;/li>
 *   &lt;li> y = −r cos (φ) &lt;/li>
 *   &lt;li> z = -r sin(θ) sin(φ) &lt;/li>
 *   &lt;li> z/x = −(r sin(θ) sin(φ)) / (r cos(θ) sin(φ)) = -sin(θ) / cos(θ) = −tanθ &lt;/li>
 *   &lt;li> θ = atan(−z/x) &lt;/li>
 *   &lt;li> φ = acos(−y/r) &lt;/li>
 * &lt;/ul>
 * Note that this definition provides a logical extension of the usual polar coordinates notation,&lt;br>
 * with θ remaining the angle in the zx-plane and φ becoming the angle out of that plane.
 *
 *  @param {vec3} p a point on the sphere.
 *  @return {Object&lt;s:Number, t:Number>} point p in spherical coordinates:
 *  &lt;ul>
 *     &lt;li>const [x, y, z] = p&lt;/li>
 *     &lt;li>r = 1 = √(x² + y² + z²)&lt;/li>
 *     &lt;li>s = θ = atan2(-z, x) / 2π + 0.5&lt;/li>
 *     &lt;li>t = φ = acos(-y/r) / π&lt;/li>
 *     &lt;li>tg(-θ) = -tg(θ) = tan (z/x)
 *     &lt;li>arctan(-θ) = -arctan(θ) = atan2(z, x)
 *  &lt;/ul>
 *
 * Since the positive angular direction is CCW,
 * we can not use North-Clockwise Convention,
 * because the image would be rendered mirrored.
 * &lt;ul>
 *  &lt;li>border ≡ antimeridian
 *  &lt;li>atan2(-z, x) (border at -x axis of the image - wrap left to right) (correct form) or &lt;/li>
 *  &lt;li>atan2(z, -x) (border at x axis of the image - wrap right to left). &lt;/li>
 *  &lt;li>atan2(z, x) (border at x axis of the image - mirrored). &lt;/li>
 * &lt;/ul>
 *
 * @see {@link https://people.computing.clemson.edu/~dhouse/courses/405/notes/texture-maps.pdf#page=3 Texture Mapping}
 * @see {@link https://en.wikipedia.org/wiki/Spherical_coordinate_system Spherical coordinate system}
 * @see {@link https://en.wikipedia.org/wiki/Parametrization_(geometry) Parametrization (geometry)}
 * @see {@link https://math.libretexts.org/Courses/Monroe_Community_College/MTH_212_Calculus_III/Chapter_11%3A_Vectors_and_the_Geometry_of_Space/11.7%3A_Cylindrical_and_Spherical_Coordinates Cylindrical and Spherical Coordinates}
 * @see {@link https://pro.arcgis.com/en/pro-app/latest/help/mapping/properties/coordinate-systems-and-projections.htm Coordinate systems}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2 Math.atan2()}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acos Math.acos()}
 * @see {@link https://en.wikipedia.org/wiki/Atan2 atan2}
 * @see &lt;img src="../images/spherical-projection.png" width = "256">
 * @see &lt;img src="../images/Spherical2.png" width="356">
 *      &lt;img src="../images/Declination.jpg" width="175">
 */
export function cartesian2Spherical(p) {
  const [x, y, z] = p;

  // acos ∈ [0,pi] ⇒ phi ∈ [0,1]
  // acos (-y) = π - acos (y)
  const phi = Math.acos(-y) / Math.PI;

  // atan2 ∈ [-pi,pi] ⇒ theta ∈ [-0.5, 0.5]
  let theta = Math.atan2(-z, x) / (2 * Math.PI);

  // theta ∈ [0, 1]
  theta += 0.5;

  return {
    s: clamp(theta, 0.0, 1.0),
    t: clamp(phi, 0.0, 1.0),
  };
}

/**
 * &lt;p>Return a point on the unit sphere given their
 * {@link https://people.computing.clemson.edu/~dhouse/courses/405/notes/texture-maps.pdf#page=3 spherical coordinates}: (θ, φ, r=1).&lt;/p>
 * It is assumed that:
 * &lt;ul>
 *  &lt;li>the two systems have the same origin,&lt;/li>
 *  &lt;li>the spherical reference plane is the Cartesian xz plane, &lt;/li>
 *  &lt;li>φ is inclination from the y direction, and&lt;/li>
 *  &lt;li>the azimuth is measured from the Cartesian x axis, so that the x axis has θ = 0° (prime meridian).&lt;/li>
 *  &lt;li>x = p[0] = r cos(θ) * sin(φ)&lt;/li>
 *  &lt;li>z = p[2] = -r sin(θ) * sin(φ)&lt;/li>
 *  &lt;li>y = p[1] = -r cos(φ)&lt;/li>
 * &lt;/ul>
 *
 * @param {Number} s azimuth angle θ, 0 ≤ θ ≤ 2π.
 * @param {Number} t zenith angle φ, 0 ≤ φ ≤ π.
 * @param {Number} r radius distance, r ≥ 0.
 * @returns {vec3} cartesian point onto the unit sphere.
 * @see {@link https://mathworld.wolfram.com/SphericalCoordinates.html spherical coordinates}
 * @see &lt;img src="../images/spherical-projection.png" width="256">
 */
export function spherical2Cartesian(s, t, r = 1) {
  const x = r * Math.cos(s) * Math.sin(t);
  const z = -r * Math.sin(s) * Math.sin(t);
  const y = -r * Math.cos(t);
  return vec3.fromValues(x, y, z);
}

/**
 * &lt;p>Convert a 2D point in spherical coordinates to a 2D point in
 * {@link https://en.wikipedia.org/wiki/Mercator_projection Mercator coordinates}.&lt;/p>
 * &lt;p>The Mercator projection is a map projection that was widely used for navigation,
 * since {@link https://www.atractor.pt/mat/loxodromica/mercator_loxodromica-_en.html loxodromes}
 * are straight lines (although great circles are curved).&lt;/p>
 * The following {@link https://mathworld.wolfram.com/MercatorProjection.html equations}
 * place the x-axis of the projection on the equator,
 * and the y-axis at longitude θ&lt;sub>0&lt;/sub>, where θ is the longitude and φ is the latitude:
 * &lt;ul>
 *    &lt;li>x =	θ - θ&lt;sub>0&lt;/sub>, 0 ≤ θ - θ&lt;sub>0&lt;/sub> ≤ 2π&lt;/li>
 *    &lt;li>&lt;span style="display: flex;">y = ∫ &lt;span style="display: flex; align-items: center; flex-direction: column; font-size: 0.75rem;">&lt;sup>φ&lt;/sup> &lt;sub>0&lt;/sub>&lt;/span>sec(φ) dφ = ln [tan (π/4 + φ/2)], -π/2 ≤ φ ≤ π/2 → -π ≤ y ≤ π &lt;/span>&lt;/li>
 * &lt;/ul>
 * The poles extent to infinity. Therefore, to create a square image,
 * the maximum latitude occurs at y = π, namely:
 * &lt;ul>
 *    &lt;li>φ&lt;sub>max&lt;/sub> = 2 atan (e&lt;sup>π&lt;/sup>) - π /2 = 85.051129°&lt;/li>
 * &lt;/ul>
 * As a consequence, we clamp the latitude to &amp;#91;-85°,85°&amp;#93; to avoid any artifact.
 * @param {Number} s longitude (horizontal angle) θ, 0 ≤ θ ≤ 1.
 * @param {Number} t latitude (vertical angle) φ, 0 ≤ φ ≤ 1.
 * @return {Object&lt;x:Number, y:Number>} mercator coordinates in [0,1].
 * @see {@link https://stackoverflow.com/questions/59907996/shader-that-transforms-a-mercator-projection-to-equirectangular mercator projection to equirectangular}
 * @see {@link https://paulbourke.net/panorama/webmerc2sphere/ Converting Web Mercator projection to equirectangular}
 * @see &lt;a href="https://ccv.eng.wayne.edu/reference/mercator-15dec2015.pdf#page=35">The normal Mercator projection&lt;/a>
 * @see {@link http://math2.org/math/integrals/more/sec.htm Integral sec(x)}
 * @see &lt;img src="../images/cylProj.png" width="556">
 * @see &lt;img src="../images/merc.png" width="128">
 */
export function spherical2Mercator(s, t) {
  // st (uv) to equirectangular
  const lon = s * 2.0 * Math.PI; // [0, 2pi]
  let lat = (t - 0.5) * Math.PI; // [-pi/2, pi/2]
  lat = clamp(lat, radians(-85.0), radians(85.0));

  // equirectangular to mercator
  let x = lon;
  let y = Math.log(Math.tan(Math.PI / 4.0 + lat / 2.0)); // [-pi, pi]

  // bring x,y into [0,1] range
  x = s;
  y = (y + Math.PI) / (2.0 * Math.PI);

  return {
    x: x,
    y: y,
  };
}

/**
 * Convert a 2D point (x=long, y=lat) in {@link https://en.wikipedia.org/wiki/Mercator_projection mercator coordinates}
 * to a 2D point (θ, φ) in {@link https://paulbourke.net/geometry/transformationprojection/ spherical coordinates}.
 * &lt;ul>
 *    &lt;li>θ =	x + θ&lt;sub>0&lt;/sub>, 0 ≤ x + θ&lt;sub>0&lt;/sub> ≤ 2π&lt;/li>
 *    &lt;li>φ =	2 atan (exp (y)) - π/2, -π ≤ y ≤ π → -85.051129° ≤ φ ≤ 85.051129° &lt;/li>
 * &lt;/ul>
 * @param {Number} x longitude in [0,1].
 * @param {Number} y latitude in [0,1].
 * @returns {Object&lt;x:Number, y:Number>} spherical coordinates in [0,1].
 * @see &lt;img src="../images/Cylindrical_Projection_basics2.svg">
 */
export function mercator2Spherical(x, y) {
  const lat = y * 2 * Math.PI - Math.PI; // [-pi, pi]
  let t = 2 * Math.atan(Math.exp(lat)) - Math.PI / 2; // [-pi/2, pi/2]
  t = t / Math.PI + 0.5; // [0, 1]
  return {
    s: x,
    t: t,
  };
}

/**
 * Set Mercator vertex coordinates.
 * @param {module:polyhedron~polyData} obj model data.
 */
export function setMercatorCoordinates(obj) {
  obj.vertexMercatorCoords = new Float32Array(obj.vertexTextureCoords.length);
  for (let i = 0; i &lt; obj.vertexTextureCoords.length; i += 2) {
    const s = obj.vertexTextureCoords[i];
    const t = obj.vertexTextureCoords[i + 1];
    const { x, y } = spherical2Mercator(s, t);
    obj.vertexMercatorCoords[i] = x;
    obj.vertexMercatorCoords[i + 1] = y;
  }
}

/**
 * Rotate u texture coordinate by a given angle.
 * @param {module:polyhedron~polyData} obj model data.
 * @param {Number} degrees rotation angle.
 */
export function rotateUTexture(obj, degrees) {
  const du = degrees / 360 + 1;
  const uv = obj.vertexTextureCoords;
  for (let i = 0; i &lt; uv.length; i += 2) {
    uv[i] += du;
    if (uv[i] > 1) uv[i] -= 1;
  }
}

/**
 * Return an array with n points on a parallel given its
 * {@link https://www.britannica.com/science/latitude latitude}.
 * @param {Number} [latitude=0] distance north or south of the Equator: [-90°,90°].
 * @param {Number} [n={@link nsegments}] number of points.
 * @return {Float32Array} points on the parallel.
 */
export function pointsOnParallel(latitude = 0, n = nsegments) {
  const ds = (Math.PI * 2) / (n - 1);
  const arr = new Float32Array(3 * n);
  let phi = clamp(latitude, -90, 90) + 90;
  phi = radians(phi);
  for (let i = 0, j = 0; i &lt; n; ++i, j += 3) {
    const p = spherical2Cartesian(i * ds, phi, 1.01);
    arr[j] = p[0];
    arr[j + 1] = p[1];
    arr[j + 2] = p[2];
  }
  return arr;
}

/**
 * Return an array with n points on the equator.
 * @param {Number} [n={@link nsegments}] number of points.
 * @return {Float32Array} points on the equator.
 */
export function pointsOnEquator(n = nsegments) {
  return pointsOnParallel(0, n);
}

/**
 * Return an array with n points on the prime meridian.
 * @param {Number} [n={@link nsegments}] number of points.
 * @return {Float32Array} points on the prime meridian.
 */
export function pointsOnPrimeMeridian(n = nsegments) {
  return pointsOnMeridian(0, n, false);
}

/**
 * Return an array with n points on the anti meridian.
 * @param {Number} [n={@link nsegments}] number of points.
 * @return {Float32Array} points on the anti meridian.
 */
export function pointsOnAntiMeridian(n = nsegments) {
  return pointsOnMeridian(180, n, false);
}

/**
 * Return an array with n points on a meridian given its
 * {@link https://en.wikipedia.org/wiki/Longitude longitude}.
 * @param {Number} [longitude=0] distance east or west of the prime meridian: [-180°,180°]
 * @param {Number} [n={@link nsegments}] number of points.
 * @param {Boolean} [anti=false] whether to draw the antimeridian also.
 * @return {Float32Array} points on the meridian.
 */
export function pointsOnMeridian(longitude = 0, n = nsegments, anti = false) {
  let j = 0;
  let ds = Math.PI / (n - 1);
  if (anti) ds *= 2;
  const arr = new Float32Array(3 * n);
  let theta = clamp(longitude, -180, 180);
  theta = radians(theta);
  for (let i = 0; i &lt; n; ++i, j += 3) {
    const p = spherical2Cartesian(theta, i * ds, 1.01);
    arr[j] = p[0];
    arr[j + 1] = p[1];
    arr[j + 2] = p[2];
  }
  return arr;
}

/**
 * &lt;p>Class for creating the model of a sphere by continuously subdividing a
 * {@link https://en.wikipedia.org/wiki/Regular_polyhedron convex regular polyhedron}.&lt;/p>
 *
 * {@link https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/mercator-its-not-hip-to-be-square Mercator coordinates}
 * are created and returned as a {@link module:polyhedron~polyData polyData}'s property, vertexMercatorCoords, and
 * {@link https://threejs.org/docs/#api/en/geometries/PolyhedronGeometry Three.js polyhedra}
 * texture coordinates are rotated by 180°, because their original coordinates
 * reversed the places of the prime and anti meridians.
 * @see &lt;img src="../images/simple-cylindrical-projection-earth-map-globe-mercator.jpg" width="512">
 */
export class Polyhedron {
  /**
   * @constructs Polyhedron
   * @param {Boolean} fix whether to fix uv coordinates.
   */
  constructor(fix = false) {
    /**
     * &lt;p>Whether texture coordinates should be fixed.&lt;/p>
     *
     * @deprecated in face of {@link https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b Tarini's}
     * method executed in the fragment shader.&lt;/p>
     * @type {Boolean}
     */
    this.fix = fix;
    /**
     * Name (type) of the subdivided polyhedron.
     * @type {String}
     */
    this.name = "";

    /**
     * Return the number of triangles at a given subdivision level.
     * @param {Number} n level of detail.
     * @returns {Number} number of triangles: nfaces * 4&lt;sup>n&lt;/sup>.
     */
    this.ntriHWS = (n) => this.nfaces * 4 ** Math.min(n, this.maxSubdivisions);

    /**
     * Return the subdivision level given a number of triangles.
     * @param {Number} t number of triangles.
     * @returns {Number} level of detail: log₄(t / nfaces).
     */
    this.levelHWS = (t) => Math.log(t / this.nfaces) / Math.log(4);

    /**
     * Return the number of triangles at a given subdivision level.
     * @param {Number} n level of detail.
     * @returns {Number} number of triangles: nfaces * (n² + 2n + 1).
     */
    this.ntri = (n) => {
      n = Math.min(n, this.maxSubdivisions);
      return this.nfaces * (n * n + 2 * n + 1);
    };

    /**
     * Return the subdivision level given a number of triangles.
     * @param {Number} t number of triangles.
     * @returns {Number} level of detail n: n² + 2n + 1 - t = 0.
     */
    this.level = (t) => {
      const a = 1;
      const b = 2;
      const c = 1 - t / this.nfaces;
      const delta = b * b - 4 * a * c;
      const root = Math.sqrt(delta) / (2 * a);
      return Math.ceil(root) - 1;
    };
  }

  /**
   * Start with empty buffers.
   */
  resetBuffers() {
    /**
     * Number of vertices.
     * @type {Number}
     */
    this.index = 0;

    /**
     * Vertex coordinate array.
     * @type {Array&lt;Number>}
     */
    this.pointsArray = [];

    /**
     * Vertex normal array.
     * @type {Array&lt;Number>}
     */
    this.normalsArray = [];

    /**
     * Index array (triangular face indices).
     * @type {Array&lt;Number>}
     */
    this.pointsIndices = [];

    /**
     * Vertex texture coordinate array.
     * @type {Array&lt;Number>}
     */
    this.texCoords = [];

    /**
     * Vertex mercator texture coordinate array.
     * @type {Array&lt;Number>}
     */
    this.mercCoords = [];
  }

  /**
   * &lt;p>Adds a new triangle.&lt;/p>
   * Mercator texture coordinates are also set.
   * @param {vec3} a first vertex.
   * @param {vec3} b second vertex.
   * @param {vec3} c third vertex.
   */
  triangle(a, b, c) {
    this.pointsArray.push(...a, ...b, ...c);

    this.pointsIndices.push(this.index, this.index + 1, this.index + 2);

    const sc = [
      cartesian2Spherical(a),
      cartesian2Spherical(b),
      cartesian2Spherical(c),
    ];

    if (this.fix) this.fixUVCoordinates(sc);

    for (const uv of sc) {
      const { s, t } = uv;
      this.texCoords.push(s, t);

      const { x, y } = spherical2Mercator(s, t);
      this.mercCoords.push(x, y);
    }

    // normals are vectors
    this.normalsArray.push(...a, ...b, ...c);

    this.index += 3;
  }

  /**
   * Recursively subdivides a triangle.
   * @param {vec3} a first vertex.
   * @param {vec3} b second vertex.
   * @param {vec3} c third vertex.
   * @param {Number} count subdivision counter.
   */
  divideTriangle(a, b, c, count) {
    if (count > 0) {
      const ab = vec3.create();
      const ac = vec3.create();
      const bc = vec3.create();
      vec3.scale(ab, vec3.add(ab, a, b), 0.5);
      vec3.scale(ac, vec3.add(ac, a, c), 0.5);
      vec3.scale(bc, vec3.add(bc, b, c), 0.5);

      // project the new points onto the unit sphere
      vec3.normalize(ab, ab);
      vec3.normalize(ac, ac);
      vec3.normalize(bc, bc);

      this.divideTriangle(a, ab, ac, count - 1);
      this.divideTriangle(ab, b, bc, count - 1);
      this.divideTriangle(bc, c, ac, count - 1);
      this.divideTriangle(ab, bc, ac, count - 1);
    } else {
      this.triangle(a, b, c);
    }
  }

  /**
   * &lt;p>Subdivides an initial {@link module:polyhedron~initialTet tetrahedron}.&lt;/p>
   * &lt;p>WebGL's vertex index buffers are limited to 16-bit (0-65535) right now:
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 4 * 4&lt;sup>n&lt;/sup> triangles&lt;/li>
   *  &lt;li> 4 * 3 * 4&lt;sup>n&lt;/sup> vertices&lt;/li>
   *  &lt;li> maximum level = 6 (16384 triangles)&lt;/li>
   *  &lt;li> 4 * 3 * 4**7 = 196608 vertices → buffer overflow&lt;/li>
   * &lt;/ul>
   * @param {Object} poly tetrahedron.
   * @property {Array&lt;vec3>} poly.vtx=initialTet.cube vertices of initial tetrahedron.
   * @property {Number} poly.n=limit.tet_hws number of subdivisions.
   * @returns {module:polyhedron~polyData}
   */
  tetrahedronHWS({ vtx = initialTet.cube, n = limit.tet_hws }) {
    this.name = "tetrahedronHWS";
    /**
     * Initial number of triangles.
     * @type {Number}
     */
    this.nfaces = 4;
    /**
     * Maximum number of subdivisions.
     * @type {Number}
     */
    this.maxSubdivisions = limit.tet_hws;

    const [a, b, c, d] = vtx;
    this.resetBuffers();

    n = Math.min(limit.tet_hws, n);

    this.divideTriangle(c, b, a, n);
    this.divideTriangle(b, c, d, n);
    this.divideTriangle(b, d, a, n);
    this.divideTriangle(d, c, a, n);

    return {
      vertexPositions: new Float32Array(this.pointsArray),
      vertexNormals: new Float32Array(this.normalsArray),
      vertexTextureCoords: new Float32Array(this.texCoords),
      vertexMercatorCoords: new Float32Array(this.mercCoords),
      indices: new Uint16Array(this.pointsIndices),
      maxSubdivisions: this.maxSubdivisions,
      name: this.name,
      nfaces: this.nfaces,
      ntri: this.ntriHWS,
      level: this.levelHWS,
    };
  }

  /**
   * &lt;p>Subdivides an initial {@link module:polyhedron~initialOcta octahedron}.&lt;/p>
   * &lt;p>WebGL's vertex index buffers are limited to 16-bit (0-65535) right now:
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 8 * 4&lt;sup>n&lt;/sup> triangles&lt;/li>
   *  &lt;li> 8 * 3 * 4&lt;sup>n&lt;/sup> vertices&lt;/li>
   *  &lt;li> maximum level = 5 (8192 triangles)&lt;/li>
   *  &lt;li> 8 * 3 * 4**6 = 98304 vertices → buffer overflow&lt;/li>
   * &lt;/ul>
   * @param {Object} poly octahedron.
   * @property {Array&lt;vec3>} poly.vtx=initialOcta vertices of initial octahedron.
   * @property {Number} poly.n=limit.oct_hws number of subdivisions.
   * @returns {module:polyhedron~polyData}
   */
  octahedronHWS({ vtx = initialOcta, n = limit.oct_hws }) {
    this.name = "octahedronHWS";
    this.nfaces = 8;
    this.maxSubdivisions = limit.oct_hws;

    const [a, b, c, d, e, f] = vtx;
    this.resetBuffers();

    n = Math.min(limit.oct_hws, n);

    this.divideTriangle(b, c, e, n);
    this.divideTriangle(f, c, b, n);
    this.divideTriangle(b, e, d, n);
    this.divideTriangle(f, b, d, n);
    this.divideTriangle(c, a, e, n);
    this.divideTriangle(c, f, a, n);
    this.divideTriangle(a, d, e, n);
    this.divideTriangle(a, f, d, n);

    return {
      vertexPositions: new Float32Array(this.pointsArray),
      vertexNormals: new Float32Array(this.normalsArray),
      vertexTextureCoords: new Float32Array(this.texCoords),
      vertexMercatorCoords: new Float32Array(this.mercCoords),
      indices: new Uint16Array(this.pointsIndices),
      maxSubdivisions: this.maxSubdivisions,
      nfaces: this.nfaces,
      name: this.name,
      ntri: this.ntriHWS,
      level: this.levelHWS,
    };
  }

  /**
   * &lt;p>Subdivides an initial {@link module:polyhedron~initialIco icosahedron}.&lt;/p>
   * &lt;p>WebGL's vertex index buffers are limited to 16-bit (0-65535) right now:
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 20 * 4&lt;sup>n&lt;/sup> triangles&lt;/li>
   *  &lt;li> 20 * 3 * 4&lt;sup>n&lt;/sup> vertices&lt;/li>
   *  &lt;li> maximum level = 5 (20480 triangles)&lt;/li>
   *  &lt;li> 20 * 3 * 4**6 = 245760 vertices → buffer overflow&lt;/li>
   * &lt;/ul>
   * @param {Object} poly icosahedron.
   * @property {Array&lt;vec3>} poly.vtx=initialIco vertices of initial octahedron.
   * @property {Number} poly.n=limit.ico_hws number of subdivisions.
   * @returns {module:polyhedron~polyData}
   */
  icosahedronHWS({ vtx = initialIco, n = limit.ico_hws }) {
    this.name = "icosahedronHWS";
    this.nfaces = 20;
    this.maxSubdivisions = limit.ico_hws;

    // prettier-ignore
    const [v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11] = vtx;

    this.resetBuffers();

    n = Math.min(limit.ico_hws, n);
    this.divideTriangle(v1, v2, v6, n);
    this.divideTriangle(v1, v7, v2, n);
    this.divideTriangle(v3, v4, v5, n);
    this.divideTriangle(v4, v3, v8, n);
    this.divideTriangle(v6, v5, v11, n);
    this.divideTriangle(v5, v6, v10, n);
    this.divideTriangle(v9, v10, v2, n);
    this.divideTriangle(v10, v9, v3, n);
    this.divideTriangle(v7, v8, v9, n);
    this.divideTriangle(v8, v7, v0, n);
    this.divideTriangle(v11, v0, v1, n);
    this.divideTriangle(v0, v11, v4, n);
    this.divideTriangle(v6, v2, v10, n);
    this.divideTriangle(v1, v6, v11, n);
    this.divideTriangle(v3, v5, v10, n);
    this.divideTriangle(v5, v4, v11, n);
    this.divideTriangle(v2, v7, v9, n);
    this.divideTriangle(v7, v1, v0, n);
    this.divideTriangle(v3, v9, v8, n);
    this.divideTriangle(v4, v8, v0, n);

    return {
      vertexPositions: new Float32Array(this.pointsArray),
      vertexNormals: new Float32Array(this.normalsArray),
      vertexTextureCoords: new Float32Array(this.texCoords),
      vertexMercatorCoords: new Float32Array(this.mercCoords),
      indices: new Uint16Array(this.pointsIndices),
      maxSubdivisions: this.maxSubdivisions,
      nfaces: this.nfaces,
      name: this.name,
      ntri: this.ntriHWS,
      level: this.levelHWS,
    };
  }

  /**
   * &lt;p>Subdivides an initial {@link module:polyhedron~initialDod dodecahedron}.&lt;/p>
   * &lt;p>WebGL's vertex index buffers are limited to 16-bit (0-65535) right now:
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 36 * 4&lt;sup>n&lt;/sup> triangles&lt;/li>
   *  &lt;li> 36 * 3 * 4&lt;sup>n&lt;/sup> vertices&lt;/li>
   *  &lt;li> maximum level = 4 (9216 triangles)&lt;/li>
   *  &lt;li> 36 * 3 * 4**5 = 110592 vertices → buffer overflow&lt;/li>
   * &lt;/ul>
   * @param {Object} poly dodecahedron.
   * @property {Array&lt;vec3>} poly.vtx=initialDod vertices of initial dodecahedron.
   * @property {Number} poly.n=limit.dod_hws number of subdivisions.
   * @returns {module:polyhedron~polyData}
   */
  dodecahedronHWS({ vtx = initialDod, n = limit.dod_hws }) {
    this.name = "dodecahedronHWS";
    this.nfaces = 36;
    this.maxSubdivisions = limit.dod_hws;

    // prettier-ignore
    const [v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19] = vtx;

    this.resetBuffers();

    n = Math.min(limit.ico_hws, n);
    this.divideTriangle(v19, v18, v4, n);
    this.divideTriangle(v19, v4, v3, n);
    this.divideTriangle(v19, v3, v13, n);

    this.divideTriangle(v19, v13, v12, n);
    this.divideTriangle(v19, v12, v16, n);
    this.divideTriangle(v19, v16, v15, n);

    this.divideTriangle(v11, v16, v12, n);
    this.divideTriangle(v11, v12, v9, n);
    this.divideTriangle(v11, v9, v8, n);

    this.divideTriangle(v5, v0, v4, n);
    this.divideTriangle(v5, v4, v18, n);
    this.divideTriangle(v5, v18, v17, n);

    this.divideTriangle(v14, v10, v6, n);
    this.divideTriangle(v14, v6, v5, n);
    this.divideTriangle(v14, v5, v17, n);

    this.divideTriangle(v14, v17, v18, n);
    this.divideTriangle(v14, v18, v19, n);
    this.divideTriangle(v14, v19, v15, n);

    this.divideTriangle(v14, v15, v16, n);
    this.divideTriangle(v14, v16, v11, n);
    this.divideTriangle(v14, v11, v10, n);

    this.divideTriangle(v12, v13, v3, n);
    this.divideTriangle(v12, v3, v2, n);
    this.divideTriangle(v12, v2, v9, n);

    this.divideTriangle(v8, v7, v6, n);
    this.divideTriangle(v8, v6, v10, n);
    this.divideTriangle(v8, v10, v11, n);

    this.divideTriangle(v1, v7, v8, n);
    this.divideTriangle(v1, v8, v9, n);
    this.divideTriangle(v1, v9, v2, n);

    this.divideTriangle(v1, v0, v5, n);
    this.divideTriangle(v1, v5, v6, n);
    this.divideTriangle(v1, v6, v7, n);

    this.divideTriangle(v0, v1, v2, n);
    this.divideTriangle(v0, v2, v3, n);
    this.divideTriangle(v0, v3, v4, n);

    return {
      vertexPositions: new Float32Array(this.pointsArray),
      vertexNormals: new Float32Array(this.normalsArray),
      vertexTextureCoords: new Float32Array(this.texCoords),
      vertexMercatorCoords: new Float32Array(this.mercCoords),
      indices: new Uint16Array(this.pointsIndices),
      maxSubdivisions: this.maxSubdivisions,
      nfaces: this.nfaces,
      name: this.name,
      ntri: this.ntriHWS,
      level: this.levelHWS,
    };
  }

  /**
   * &lt;p>Subdivides an initial
   * {@link https://threejs.org/docs/#api/en/geometries/TetrahedronGeometry tetrahedron}.&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 4(n² + 2n + 1) &lt;/li>
   *  &lt;li> n = 0: 4 triangles, 4 vertices&lt;/li>
   *  &lt;li> n = 1: 16 triangles, 10 vertices&lt;/li>
   *  &lt;li> n = 2: 36 triangles, 20 vertices&lt;/li>
   *  &lt;li> n = 3: 64 triangles, 34 vertices&lt;/li>
   *  &lt;li> n = 4: 100 triangles, 52 vertices&lt;/li>
   *  &lt;li> n = 5: 144 triangles, 74 vertices&lt;/li>
   * &lt;/ul>
   * @param {Object} poly tetrahedron.
   * @property {Number} poly.radius=1 radius for three.js.
   * @property {Number} poly.n=limit.tet number of subdivisions.
   * @returns {module:polyhedron~polyData}
   * @see {@link https://github.com/mrdoob/three.js/blob/master/src/geometries/TetrahedronGeometry.js TetrahedronGeometry.js}
   */
  tetrahedron({ radius = 1, n = limit.tet }) {
    this.name = "tetrahedron";
    this.nfaces = 4;
    this.maxSubdivisions = limit.tet;

    n = Math.min(limit.tet, n);

    const obj = getModelData(new THREE.TetrahedronGeometry(radius, n));

    // rotate texture by 180°
    rotateUTexture(obj, 180);

    setMercatorCoordinates(obj);

    obj.maxSubdivisions = this.maxSubdivisions;
    obj.nfaces = this.nfaces;
    obj.name = this.name;
    obj.ntri = this.ntri;
    obj.level = this.level;

    return obj;
  }

  /**
   * &lt;p>Subdivides an initial
   * {@link https://threejs.org/docs/#api/en/geometries/OctahedronGeometry octhedron}.&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 8(n² + 2n + 1) &lt;/li>
   *  &lt;li> n = 0: 8 triangles, 6 vertices&lt;/li>
   *  &lt;li> n = 1: 32 triangles, 18 vertices&lt;/li>
   *  &lt;li> n = 2: 72 triangles, 38 vertices&lt;/li>
   *  &lt;li> n = 3: 192 triangles, 66 vertices&lt;/li>
   *  &lt;li> n = 4: 200 triangles, 102 vertices&lt;/li>
   *  &lt;li> n = 5: 288 triangles, 146 vertices&lt;/li>
   * &lt;/ul>
   * @param {Object} poly octahedron.
   * @property {Number} poly.radius=1 radius for three.js.
   * @property {Number} poly.n=limit.oct number of subdivisions.
   * @returns {module:polyhedron~polyData}
   * @see {@link https://github.com/mrdoob/three.js/blob/master/src/geometries/OctahedronGeometry.js OctahedronGeometry.js}
   */
  octahedron({ radius = 1, n = limit.oct }) {
    this.name = "octahedron";
    this.nfaces = 8;
    this.maxSubdivisions = limit.oct;

    n = Math.min(limit.oct, n);

    const obj = getModelData(new THREE.OctahedronGeometry(radius, n));

    // rotate texture by 180°
    rotateUTexture(obj, 180);

    setMercatorCoordinates(obj);

    obj.maxSubdivisions = this.maxSubdivisions;
    obj.nfaces = this.nfaces;
    obj.name = this.name;
    obj.ntri = this.ntri;
    obj.level = this.level;

    return obj;
  }

  /**
   * &lt;p>Subdivides an initial
   * {@link https://threejs.org/docs/#api/en/geometries/DodecahedronGeometry dodecahedron}.&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 36(n² + 2n + 1) &lt;/li>
   *  &lt;li> n = 0: 36 triangles, 20 vertices&lt;/li>
   *  &lt;li> n = 1: 144 triangles, 74 vertices&lt;/li>
   *  &lt;li> n = 2: 324 triangles, 164 vertices&lt;/li>
   *  &lt;li> n = 3: 576 triangles, 290 vertices&lt;/li>
   *  &lt;li> n = 4: 900 triangles, 452 vertices&lt;/li>
   *  &lt;li> n = 5: 1296 triangles, 650 vertices&lt;/li>
   * &lt;/ul>
   * @param {Object} poly dodecahedron.
   * @property {Number} poly.radius=1 radius of the dodecahedron.
   * @property {Number} poly.n=limit.dod number of subdivisions.
   * @returns {module:polyhedron~polyData}
   * @see {@link https://github.com/mrdoob/three.js/blob/master/src/geometries/DodecahedronGeometry.js DodecahedronGeometry.js}
   */
  dodecahedron({ radius = 1, n = limit.dod }) {
    this.name = "dodecahedron";
    this.nfaces = 36;
    this.maxSubdivisions = limit.dod;

    n = Math.min(limit.dod, n);

    const obj = getModelData(new THREE.DodecahedronGeometry(radius, n));

    // rotate texture by 180°
    rotateUTexture(obj, 180);

    setMercatorCoordinates(obj);

    obj.maxSubdivisions = this.maxSubdivisions;
    obj.nfaces = this.nfaces;
    obj.name = this.name;
    obj.ntri = this.ntri;
    obj.level = this.level;

    return obj;
  }

  /**
   * &lt;p>Subdivides an initial
   * {@link https://threejs.org/docs/#api/en/geometries/IcosahedronGeometry icosahedron}.&lt;/p>
   * Generates:
   * &lt;ul>
   *  &lt;li> 20(n² + 2n + 1) &lt;/li>
   *  &lt;li> n = 0: 20 triangles, 12 vertices&lt;/li>
   *  &lt;li> n = 1: 80 triangles, 42 vertices&lt;/li>
   *  &lt;li> n = 2: 180 triangles, 92 vertices&lt;/li>
   *  &lt;li> n = 3: 320 triangles, 162 vertices&lt;/li>
   *  &lt;li> n = 4: 500 triangles, 252 vertices&lt;/li>
   *  &lt;li> n = 5: 720 triangles, 362 vertices&lt;/li>
   * &lt;/ul>
   * @param {Object} poly icosahedron.
   * @property {Number} poly.radius=1 radius of the icosahedron.
   * @property {Number} poly.n=limit.ico number of subdivisions.
   * @returns {module:polyhedron~polyData}
   * @see {@link https://github.com/mrdoob/three.js/blob/master/src/geometries/IcosahedronGeometry.js IcosahedronGeometry.js}
   */
  icosahedron({ radius = 1, n = limit.ico }) {
    this.name = "icosahedron";
    this.nfaces = 20;
    this.maxSubdivisions = limit.ico;

    n = Math.min(limit.ico, n);

    const obj = getModelData(new THREE.IcosahedronGeometry(radius, n));

    // rotate texture by 180°
    rotateUTexture(obj, 180);

    setMercatorCoordinates(obj);

    obj.maxSubdivisions = this.maxSubdivisions;
    obj.nfaces = this.nfaces;
    obj.name = this.name;
    obj.ntri = this.ntri;
    obj.level = this.level;

    return obj;
  }

  /**
   * &lt;p>Equirectangular mapping (also called latitude/longitude or spherical coordinates) is non-linear.&lt;br>
   * That means normal UV mapping can only approximate it - quite badly at the poles, in fact.&lt;/p>
   *
   * &lt;p>To fix this, we can calculate our own texture coordinate per fragment, &lt;br>
   * by using the direction to the fragment being drawn, resulting in a perfect match.&lt;/p>
   *
   * As a last resource, we can try to adjust uv texture coordinates,
   * when two vertices of a triangle are on one side, &lt;br>
   * and the third on the other side of the discontinuity created,
   * when the 0 coordinate is stitched together with the 1 coordinate.
   *
   * @deprecated in face of {@link https://bgolus.medium.com/distinctive-derivative-differences-cce38d36797b Tarini's}
   * method executed in the fragment shader.&lt;/p>
   *
   * @param {Array&lt;Object&lt;{s:Number, t:Number}>>} sc triangle given by its spherical coordinates.
   * @see {@link https://gamedev.stackexchange.com/questions/148167/correcting-projection-of-360-content-onto-a-sphere-distortion-at-the-poles/148178#148178 Per-Fragment Equirectangular}
   */
  fixUVCoordinates(sc) {
    const zero = 0.2;
    const onem = 1 - zero;
    const onep = 1 + zero;
    const twom = 2 - zero;
    const twop = 2 + zero;

    const s = sc[0].s + sc[1].s + sc[2].s;
    const t = sc[0].t + sc[1].t + sc[2].t;
    if (s > onem &amp;&amp; s &lt; onep) {
      // two zeros
      if (sc[0].s > onem || sc[1].s > onem || sc[2].s > onem)
        sc[0].s = sc[1].s = sc[2].s = 0;
    } else if (s > twom &amp;&amp; s &lt; twop) {
      // two ones
      if (sc[0].s &lt; zero || sc[1].s &lt; zero || sc[2].s &lt; zero)
        sc[0].s = sc[1].s = sc[2].s = 1;
    }
    if (t > onem &amp;&amp; t &lt; onep) {
      if (sc[0].t > onem || sc[1].t > onem || sc[2].t > onem)
        sc[0].t = sc[1].t = sc[2].t = 0;
    } else if (t > twom &amp;&amp; t &lt; twop) {
      if (sc[0].t &lt; zero || sc[1].t &lt; zero || sc[2].t &lt; zero)
        sc[0].t = sc[1].t = sc[2].t = 1;
    }
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glMatrix.html">glMatrix</a></li><li><a href="module-mat2.html">mat2</a></li><li><a href="module-mat2d.html">mat2d</a></li><li><a href="module-mat3.html">mat3</a></li><li><a href="module-mat4.html">mat4</a></li><li><a href="module-polyhedron.html">polyhedron</a></li><li><a href="module-quat.html">quat</a></li><li><a href="module-quat2.html">quat2</a></li><li><a href="module-vec2.html">vec2</a></li><li><a href="module-vec3.html">vec3</a></li><li><a href="module-vec4.html">vec4</a></li></ul><h3>Externals</h3><ul><li><a href="external-three.html">three</a></li></ul><h3>Namespaces</h3><ul><li><a href="THREE.html">THREE</a></li></ul><h3>Classes</h3><ul><li><a href="SimpleRotator.html">SimpleRotator</a></li><li><a href="THREE.BufferGeometry.html">BufferGeometry</a></li><li><a href="TeapotGeometry.html">TeapotGeometry</a></li><li><a href="module-polyhedron.Polyhedron.html">Polyhedron</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:changeAxescheckBox">changeAxescheckBox</a></li><li><a href="global.html#event:changeCitiescheckBox">changeCitiescheckBox</a></li><li><a href="global.html#event:changeCullcheckBox">changeCullcheckBox</a></li><li><a href="global.html#event:changeEquatorcheckBox">changeEquatorcheckBox</a></li><li><a href="global.html#event:changeFixUVcheckBox">changeFixUVcheckBox</a></li><li><a href="global.html#event:changeHwscheckBox">changeHwscheckBox</a></li><li><a href="global.html#event:changeMercatorcheckBox">changeMercatorcheckBox</a></li><li><a href="global.html#event:changeMeshcheckBox">changeMeshcheckBox</a></li><li><a href="global.html#event:changeModeInputRadio">changeModeInputRadio</a></li><li><a href="global.html#event:changeModelsSelect">changeModelsSelect</a></li><li><a href="global.html#event:changeRotInputRadio">changeRotInputRadio</a></li><li><a href="global.html#event:changeTextureSelect">changeTextureSelect</a></li><li><a href="global.html#event:changeTexturecheckBox">changeTexturecheckBox</a></li><li><a href="global.html#event:changeTooltipcheckBox">changeTooltipcheckBox</a></li><li><a href="global.html#event:clickClosest">clickClosest</a></li><li><a href="global.html#event:contextmenu">contextmenu</a></li><li><a href="global.html#event:dblclick">dblclick</a></li><li><a href="global.html#event:keydown">keydown</a></li><li><a href="global.html#event:load">load</a></li><li><a href="global.html#event:pointerdown-textimg">pointerdown-textimg</a></li><li><a href="global.html#event:pointerdown-theCanvas">pointerdown-theCanvas</a></li><li><a href="global.html#event:pointermove-textimg">pointermove-textimg</a></li><li><a href="global.html#event:pointermove-theCanvas">pointermove-theCanvas</a></li><li><a href="global.html#event:pointerout-textimg">pointerout-textimg</a></li><li><a href="global.html#event:pointerup-theCanvas">pointerup-theCanvas</a></li></ul><h3>Global</h3><ul><li><a href="global.html#UV2Spherical">UV2Spherical</a></li><li><a href="global.html#addListeners">addListeners</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#axis">axis</a></li><li><a href="global.html#axisBuffer">axisBuffer</a></li><li><a href="global.html#axisColorBuffer">axisColorBuffer</a></li><li><a href="global.html#axisColors">axisColors</a></li><li><a href="global.html#axisVertices">axisVertices</a></li><li><a href="global.html#canvas">canvas</a></li><li><a href="global.html#canvastip">canvastip</a></li><li><a href="global.html#cities">cities</a></li><li><a href="global.html#cleanLocation">cleanLocation</a></li><li><a href="global.html#closestSite">closestSite</a></li><li><a href="global.html#colorShader">colorShader</a></li><li><a href="global.html#createEvent">createEvent</a></li><li><a href="global.html#createModel">createModel</a></li><li><a href="global.html#createProgram">createProgram</a></li><li><a href="global.html#cube">cube</a></li><li><a href="global.html#culling">culling</a></li><li><a href="global.html#currentLocation">currentLocation</a></li><li><a href="global.html#currentMeridian">currentMeridian</a></li><li><a href="global.html#cursorPosition">cursorPosition</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawAxes">drawAxes</a></li><li><a href="global.html#drawLines">drawLines</a></li><li><a href="global.html#drawLinesOnImage">drawLinesOnImage</a></li><li><a href="global.html#drawLocationsOnImage">drawLocationsOnImage</a></li><li><a href="global.html#drawParallel">drawParallel</a></li><li><a href="global.html#drawTexture">drawTexture</a></li><li><a href="global.html#element">element</a></li><li><a href="global.html#eye">eye</a></li><li><a href="global.html#fixuv">fixuv</a></li><li><a href="global.html#formatNumberWithSign">formatNumberWithSign</a></li><li><a href="global.html#gcs2Screen">gcs2Screen</a></li><li><a href="global.html#gcs2UV">gcs2UV</a></li><li><a href="global.html#getChar">getChar</a></li><li><a href="global.html#getModelData">getModelData</a></li><li><a href="global.html#getModelMatrix">getModelMatrix</a></li><li><a href="global.html#getTextures">getTextures</a></li><li><a href="global.html#getWebGLContext">getWebGLContext</a></li><li><a href="global.html#gl">gl</a></li><li><a href="global.html#gpsCoordinates">gpsCoordinates</a></li><li><a href="global.html#handleKeyPress">handleKeyPress</a></li><li><a href="global.html#haversine">haversine</a></li><li><a href="global.html#image">image</a></li><li><a href="global.html#imageFilename">imageFilename</a></li><li><a href="global.html#indexBuffer">indexBuffer</a></li><li><a href="global.html#initShaders">initShaders</a></li><li><a href="global.html#isMap">isMap</a></li><li><a href="global.html#isPowerOf2">isPowerOf2</a></li><li><a href="global.html#isTouchDevice">isTouchDevice</a></li><li><a href="global.html#labelForLocation">labelForLocation</a></li><li><a href="global.html#lightPosition">lightPosition</a></li><li><a href="global.html#lightPropElements">lightPropElements</a></li><li><a href="global.html#lightingShader">lightingShader</a></li><li><a href="global.html#lineBuffer">lineBuffer</a></li><li><a href="global.html#lineSphereIntersection">lineSphereIntersection</a></li><li><a href="global.html#lines">lines</a></li><li><a href="global.html#loadShader">loadShader</a></li><li><a href="global.html#makeNormalMatrixElements">makeNormalMatrixElements</a></li><li><a href="global.html#mat3">mat3</a></li><li><a href="global.html#mat4">mat4</a></li><li><a href="global.html#matPropElements">matPropElements</a></li><li><a href="global.html#maxSubdivisions">maxSubdivisions</a></li><li><a href="global.html#mercator">mercator</a></li><li><a href="global.html#meridianBuffer">meridianBuffer</a></li><li><a href="global.html#meridianMatrix">meridianMatrix</a></li><li><a href="global.html#meridianPerpVec">meridianPerpVec</a></li><li><a href="global.html#modelMatrix">modelMatrix</a></li><li><a href="global.html#mscale">mscale</a></li><li><a href="global.html#newTexture">newTexture</a></li><li><a href="global.html#nextLevel">nextLevel</a></li><li><a href="global.html#nextTexture">nextTexture</a></li><li><a href="global.html#noTexture">noTexture</a></li><li><a href="global.html#normal">normal</a></li><li><a href="global.html#normalBuffer">normalBuffer</a></li><li><a href="global.html#numSubdivisions">numSubdivisions</a></li><li><a href="global.html#parallelBuffer">parallelBuffer</a></li><li><a href="global.html#phongHighlight">phongHighlight</a></li><li><a href="global.html#pixelRayIntersection">pixelRayIntersection</a></li><li><a href="global.html#previousLevel">previousLevel</a></li><li><a href="global.html#previousTexture">previousTexture</a></li><li><a href="global.html#project">project</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#readFileNames">readFileNames</a></li><li><a href="global.html#ring">ring</a></li><li><a href="global.html#rotMatrix">rotMatrix</a></li><li><a href="global.html#rotateModelTowardsCamera">rotateModelTowardsCamera</a></li><li><a href="global.html#rotator">rotator</a></li><li><a href="global.html#selectModel">selectModel</a></li><li><a href="global.html#selectTexture">selectTexture</a></li><li><a href="global.html#selector">selector</a></li><li><a href="global.html#setNorth">setNorth</a></li><li><a href="global.html#setPosition">setPosition</a></li><li><a href="global.html#setTextures">setTextures</a></li><li><a href="global.html#setUVfix">setUVfix</a></li><li><a href="global.html#shininess">shininess</a></li><li><a href="global.html#sortCitiesByDate">sortCitiesByDate</a></li><li><a href="global.html#spherical2gcs">spherical2gcs</a></li><li><a href="global.html#startForReal">startForReal</a></li><li><a href="global.html#teapotModel">teapotModel</a></li><li><a href="global.html#texCoordBuffer">texCoordBuffer</a></li><li><a href="global.html#textureCnt">textureCnt</a></li><li><a href="global.html#textureHandle">textureHandle</a></li><li><a href="global.html#theModel">theModel</a></li><li><a href="global.html#toRadian">toRadian</a></li><li><a href="global.html#unproject">unproject</a></li><li><a href="global.html#updateCurrentMeridian">updateCurrentMeridian</a></li><li><a href="global.html#uvCone">uvCone</a></li><li><a href="global.html#uvCylinder">uvCylinder</a></li><li><a href="global.html#uvSphere">uvSphere</a></li><li><a href="global.html#uvSphereND">uvSphereND</a></li><li><a href="global.html#uvTorus">uvTorus</a></li><li><a href="global.html#vec2">vec2</a></li><li><a href="global.html#vec3">vec3</a></li><li><a href="global.html#vec4">vec4</a></li><li><a href="global.html#vertexBuffer">vertexBuffer</a></li><li><a href="global.html#vertexNormalBuffer">vertexNormalBuffer</a></li><li><a href="global.html#viewMatrix">viewMatrix</a></li><li><a href="global.html#yNorth">yNorth</a></li><li><a href="global.html#zoomIn">zoomIn</a></li><li><a href="global.html#zoomOut">zoomOut</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Thu Jul 10 2025 07:51:49 GMT-0300 (Brasilia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
