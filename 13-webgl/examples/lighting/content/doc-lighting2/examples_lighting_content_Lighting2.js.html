<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: examples/lighting/content/Lighting2.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: examples/lighting/content/Lighting2.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 *
 * Summary.
 * &lt;p>Lighting and shading models: &lt;a href="https://en.wikipedia.org/wiki/Lambertian_reflectance">Lambert&lt;/a>  x
 * &lt;a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong&lt;/a>.  &lt;/p>
 *
 * Here, we add a {@link getModelData function} to take a model created by {@link https://threejs.org three.js}
 * and extract the data for vertices and normals, &lt;br>
 * so we can load it directly to the GPU.
 *
 * Edit {@link mainEntrance} to select a {@link selectModel model} and {@link makeCube} to set
 * {@link https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/shading-normals face or vertex normals}.
 *
 * @author Steve Kautz modified by Paulo Roma
 * @since 27/09/2016
 * @see &lt;a href="https://dl.acm.org/doi/pdf/10.1145/362736.362739">Flat shading&lt;/a> -
 * &lt;a href="https://csl.illinois.edu/news-and-media/tech-reports">Wendell Jack Bouknight&lt;/a> (1970)
 * @see &lt;a href="https://ohiostate.pressbooks.pub/app/uploads/sites/45/2017/09/gouraud1971.pdf">Gouraud shading&lt;/a> -
 * &lt;a href="https://en.wikipedia.org/wiki/Henri_Gouraud_(computer_scientist)">Henri Gouraud&lt;/a> (1971)
 * @see &lt;a href="https://dl.acm.org/doi/pdf/10.1145/360825.360839">Phong shading&lt;/a> -
 * &lt;a href="https://en.wikipedia.org/wiki/Bui_Tuong_Phong">Bui Tuong Phong&lt;/a> (1975)
 * @see &lt;a href="https://cg.cs.tsinghua.edu.cn/course/docs/chap1%20final.pdf">Computer Graphics Survey&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/lighting/content/Lighting2.js">source&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/lighting/content/Lighting2.html">Lambert diffuse model, Gouraud shading&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/lighting/content/Lighting2a.html">Lambert diffuse model, Phong shading&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/lighting/content/Lighting2b.html">Phong reflection model, Gouraud shading&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/lighting/content/Lighting2c.html">Phong reflection model, Phong shading&lt;/a>
 */

"use strict";

// CDN always works
//import * as THREE from "https://unpkg.com/three@0.148.0/build/three.module.js?module";
//import { TeapotGeometry } from "https://unpkg.com/three@0.148.0/examples/jsm/geometries/TeapotGeometry.js?module";

// importmap does not work on safari and IOS
//import * as THREE from "three";
//import { TeapotGeometry } from "TeapotGeometry";

import * as THREE from "/cwdc/13-webgl/lib/three/build/three.module.js";
import { TeapotGeometry } from "./TeapotGeometry.js";

/**
 * Three.js module.
 * @external THREE
 * @see https://threejs.org/docs/#manual/en/introduction/Installation
 */

/**
 * &lt;p>A representation of mesh, line, or point geometry.&lt;/p>
 * Includes vertex positions, face indices, normals, colors, UVs,
 * and custom attributes within buffers, reducing the cost of
 * passing all this data to the GPU.
 * @class BufferGeometry
 * @memberof external:THREE
 * @see https://threejs.org/docs/#api/en/core/BufferGeometry
 */

/**
 * Axis coordinates.
 * @type {Float32Array}
 */
// prettier-ignore
var axisVertices = new Float32Array([
  0.0, 0.0, 0.0,
  1.5, 0.0, 0.0,
  0.0, 0.0, 0.0,
  0.0, 1.5, 0.0,
  0.0, 0.0, 0.0,
  0.0, 0.0, 1.5,
]);

/**
 * Axis colors.
 * @type {Float32Array}
 */
// prettier-ignore
var axisColors = new Float32Array([
  1.0, 0.0, 0.0, 1.0,
  1.0, 0.0, 0.0, 1.0,
  0.0, 1.0, 0.0, 1.0,
  0.0, 1.0, 0.0, 1.0,
  0.0, 0.0, 1.0, 1.0,
  0.0, 0.0, 1.0, 1.0,
]);

// A few global variables...

/**
 * The OpenGL context.
 * @type {WebGLRenderingContext}
 */
var gl;

/**
 * Our model data.
 * @type {modelData}
 */
var theModel;

/**
 * Array with normal end points.
 * @type {Float32Array}
 */
var normal;

/**
 * Array with edges end points.
 * @type {Float32Array}
 */
var lines;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var vertexBuffer;
/**  @type {WebGLBuffer} */
var indexBuffer;
/**  @type {WebGLBuffer} */
var vertexNormalBuffer;
/**  @type {WebGLBuffer} */
var axisBuffer;
/**  @type {WebGLBuffer} */
var axisColorBuffer;
/**  @type {WebGLBuffer} */
var normalBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var lineBuffer;

/**
 * Handle to the compiled shader program on the GPU.
 * @type {WebGLShader}
 */
var lightingShader;

/**
 * Handle to the compiled shader program on the GPU.
 * @type {WebGLShader}
 */
var colorShader;

/**
 * Model transformation matrix.
 * @Type {Matrix4}
 */
var modelMatrix = new Matrix4();

/**
 * Current rotation axis.
 * @type {String}
 */
var axis = "x";

/**
 * Scale applied to a model to make its size adequate for rendering.
 * @type {Number}
 */
var mscale = 1;

/**
 * Turn the display of the model mesh/texture/axes/animation on/off.
 * @type {Object}
 * @property {Boolean} lines mesh visible/invisible
 * @property {Boolean} texture model surface visible/invisible
 * @property {Boolean} axes axes visible/invisible
 * @property {Boolean} paused animation on/off
 */
var selector = {
  lines: false,
  texture: true,
  axes: false,
  paused: true,
};

/**
 * Arcball.
 * @type {SimpleRotator}
 */
var rotator;

/**
 * Camera position.
 * @type {Array&lt;Number>}
 */
var eye = [1.77, 3.54, 3.06];

/**
 * &lt;p>View matrix.&lt;/p>
 * One strategy is to identify a transformation to our
 * &lt;a href="https://cglearn.codelight.eu/pub/computer-graphics/frames-of-reference-and-projection">camera&lt;/a>
 * &lt;a href="/cwdc/downloads/Computer%20Graphics%20-%20CMSC%20427.pdf#page=31">frame&lt;/a>
 * then invert it.  &lt;br>
 * Therefore, the camera transformation takes (0,0,0) to the &lt;span style="color:red">camera position.&lt;/span>
 * &lt;pre>
 *    rotate(30, 0, 1, 0) * rotate(-45, 1, 0, 0) * translate(0, 0, 5)
 *
 *    camera transformation:
 *        0.8660253882408142 -0.3535533845424652 0.3535533845424652 &lt;span style="color:red">1.7677669525146484&lt;/span>
 *        0                   0.7071067690849304 0.7071067690849304 &lt;span style="color:red">3.535533905029297&lt;/span>
 *       -0.5                -0.6123723983764648 0.6123723983764648 &lt;span style="color:red">3.061861991882324&lt;/span>
 *        0                   0                   0                 1
 *
 *    translate(0, 0, -5) * rotate(45, 1, 0, 0) * rotate(-30, 0, 1, 0)
 *
 *    view matrix:
 *        0.8660253882408142 0                  -0.5                 0
 *       -0.3535533845424652 0.7071067690849304 -0.6123723983764648  0
 *        0.3535533845424652 0.7071067690849304  0.6123723983764648 -5
 *        0                  0                   0                   1
 *
 * &lt;/pre>
 * The view matrix is the inverse of the camera's transformation matrix: viewMatrix = camera ⁻¹.
 * &lt;ul>
 * &lt;li>The camera's transformation matrix takes something that's local to the camera
 * and transforms it to world space &lt;br>
 * (transforming the point [0,0,0] will give you the camera's position)&lt;/li>
 * &lt;li>The view matrix takes something that's in world space and transforms it
 * so that it's local to the camera &lt;br>
 * (transforming the camera's position will give you [0, 0, 0])&lt;/li>
 * &lt;/ul>
 * &lt;p>&lt;a href="https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/">LookAt&lt;/a>
 * functions from math &lt;a href="https://dens.website/tutorials/webgl/gl-matrix">libraries&lt;/a> are just a convenience, indeed,
 * and requires a view point,
 * a point to look at, and a direction "up", for camera orientation:&lt;/p>
 * &lt;p>The approximate {@link eye view point} here is: &lt;span style="color:red">[1.77, 3.54, 3.06]&lt;/span>&lt;/p>
 *
 * &lt;pre>
 *    var viewMatrix = new {@link Matrix4 Matrix4()}.setLookAt(
 *      ...eye,   // view point
 *      0, 0, 0,  // at - looking at the origin
 *      0, 1, 0); // up vector - y axis
 *
 * or using the {@link https://glmatrix.net glmatrix} package
 *
 *    var viewMatrix = {@link https://glmatrix.net/docs/module-mat4.html mat4}.lookAt(
 *      [],         // mat4 frustum matrix will be written into
 *      eye,        // view point
 *      [0, 0, 0],  // look at (center)
 *      [0, 1, 0]); // view up
 * &lt;/pre>
 * @type {Matrix4}
 * @see &lt;a href="/cwdc/downloads/apostila.pdf#page=109">View matrix&lt;/a>
 * @see &lt;a href="/cwdc/downloads/PDFs/06_LCG_Transformacoes.pdf">Mudança de Base&lt;/a>
 * @see &lt;a href="https://en.wikipedia.org/wiki/Change_of_basis">Change of Basis&lt;/a>
 * @see &lt;a href="/cwdc/10-html5css3/hw2/doc-hw2">node&lt;/a>
 * @see https://learn.microsoft.com/en-us/windows/win32/direct3d9/view-transform
 * @see &lt;img src="../projection.png" width="256"> &lt;img src="../projection2.png" width="256">
 */
var viewMatrix = new Matrix4()
  .translate(0, 0, -5)
  .rotate(45, 1, 0, 0)
  .rotate(-30, 0, 1, 0);

/**
 * Returns the magnitude (length) of a vector.
 * @param {Array&lt;Number>} v n-D vector.
 * @returns {Number} vector length.
 * @see https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
 */
var vecLen = (v) =>
  Math.sqrt(v.reduce((accumulator, value) => accumulator + value * value, 0));

/**
 * View distance.
 * @type {Number}
 */
var viewDistance = vecLen(eye);

/**
 * &lt;p>For projection, we can either use:
 * &lt;ul>
 * &lt;li>An orthographic projection, specifying
 * the clipping volume explicitly:
 *  &lt;ul>
 *    &lt;li>var &lt;b>projection&lt;/b> = new Matrix4().setOrtho(-1.5, 1.5, -1, 1, 4, 6);&lt;/li>
 *  &lt;/ul>
 * &lt;/li>
 *
 * &lt;li>Or the same perspective projection, using the Frustum function with:
 *  &lt;ul>
 *    &lt;li>a 30 degree field of view, and a near plane at 4,&lt;br>
 *    which corresponds to a view plane height of: 4 * tan(15) = 1.07&lt;/li>
 *    &lt;li>var &lt;b>projection&lt;/b> = new Matrix4().setFrustum(-1.5 * 1.07, 1.5 * 1.07, -1.07, 1.07, 4, 6);&lt;/li>
 *  &lt;/ul>
 * &lt;/li>
 *
 * &lt;li>Or a perspective projection specified with a
 * field of view, an aspect ratio, and distance to near and far
 * clipping planes:
 *  &lt;ul>
 *    &lt;li>var &lt;b>projection&lt;/b> = new Matrix4().setPerspective(30, 1.5, 0.1, 1000);&lt;/li>
 *  &lt;/ul>
 * &lt;/ul>
 * Here use aspect ratio 3/2 corresponding to canvas size 900 x 600&lt;/p>
 * @type {Matrix4}
 */
var projection = new Matrix4().setPerspective(30, 1.5, 0.1, 1000);

/**
 * An object containing raw data for
 * vertices, normal vectors, texture coordinates, and indices.
 * @typedef {Object} modelData
 * @property {Float32Array} vertices vertex coordinates.
 * @property {Float32Array} normals vertex normals.
 * @property {Float32Array} texCoords texture coordinates.
 * @property {Uint16Array|Uint32Array} indices index array.
 */

/**
 * Loads the {@link mainEntrance application}.
 * @event load
 */
window.addEventListener("load", (event) => mainEntrance());

/**
 * Draws the mesh and vertex normals, by generating an "l" {@link handleKeyPress event},
 * whenever the Mesh button is clicked.
 * @event click
 */
document
  .querySelector("#btnMesh")
  .addEventListener("click", (event) => handleKeyPress(createEvent("l")));

/**
 * Animates the object, by generating an " " {@link handleKeyPress event},
 * whenever the Rotate button is clicked.
 * @event click
 */
document
  .querySelector("#btnRot")
  .addEventListener("click", (event) => handleKeyPress(createEvent(" ")));

/**
 * Animates the object, by generating an "↓" {@link handleKeyPress event},
 * whenever the Arrow Down button is clicked.
 * @event click
 */
document
  .querySelector("#arrowDown")
  .addEventListener("click", (event) =>
    handleKeyPress(createEvent("ArrowDown")),
  );

/**
 * Animates the object, by generating an "↑" {@link handleKeyPress event},
 * whenever the Arrow Up button is clicked.
 * @event click
 */
document
  .querySelector("#arrowUp")
  .addEventListener("click", (event) => handleKeyPress(createEvent("ArrowUp")));

/**
 * Given an instance of
 * &lt;ul>
 * &lt;li>{@link external:THREE.BufferGeometry THREE.BufferGeometry}&lt;/li>
 * &lt;/ul>
 * returns an object containing raw data for
 * vertices, indices, texture coordinates, and normal vectors.
 * &lt;p>{@link https://threejs.org/docs/#api/en/geometries/PolyhedronGeometry Polyhedra} have no index.&lt;/p>
 * @param {external:THREE.BufferGeometry} geom
 *        {@link https://threejs.org/docs/#api/en/geometries/BoxGeometry THREE.BoxGeometry}&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/CapsuleGeometry THREE.CapsuleGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/ConeGeometry THREE.ConeGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/CylinderGeometry THREE.CylinderGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/PlaneGeometry THREE.PlaneGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/RingGeometry THREE.RingGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/SphereGeometry THREE.SphereGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/TorusGeometry THREE.TorusGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/TorusKnotGeometry THREE.TorusKnotGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/DodecahedronGeometry THREE.DodecahedronGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/IcosahedronGeometry THREE.IcosahedronGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/OctahedronGeometry THREE.OctahedronGeometry},&lt;br>
 *        {@link https://threejs.org/docs/#api/en/geometries/TetrahedronGeometry THREE.TetrahedronGeometry}.&lt;br>
 *        {@link TeapotGeometry THREE.TeaPotGeometry}.
 * @return {modelData}
 */
function getModelData(geom) {
  return {
    vertices: geom.getAttribute("position").array,
    normals: geom.getAttribute("normal").array,
    texCoords: geom.getAttribute("uv").array,
    indices: geom.index ? geom.index.array : null,
  };
}

/**
 * &lt;p>Creates a unit cube, centered at the origin, and set its properties:
 * vertices, normal vectors, texture coordinates, indices and colors.&lt;/p>
 *
 * &lt;p>For a proper specular reflection on planar faces, such as a cube or a polyhedron,
 * the normal vectors have to be perpendicular to the plane of each face.&lt;/p>
 *
 * &lt;p>Computing an average normal, like is done here when creating indices,
 * is what one would want to do for a smooth object like a sphere.&lt;/p>
 * The resulting rendering is very unpleasant, in this case.
 * The right course is creating three duplicate vertices per cube corner.
 * &lt;p>Even if cube.indices is not defined here, {@link drawModel} can handle it.&lt;/p>
 * @param {Boolean} create_indices whether to generated vertex indices or not.
 * @return {Object} cube
 * @property {Number} cube.numVertices number of vertices (36).
 * @property {Float32Array} cube.vertices vertex coordinate array (108 = 36 * 3).
 * @property {Float32Array} cube.normals vertex normal array (108 = 36 * 3).
 * @property {Float32Array} cube.colors vertex color array (144 = 36 * 4).
 * @property {Float32Array} cube.texCoords vertex texture array (72 = 36 * 2).
 * @property {Uint16Array} cube.indices vertex index array (36 = 6 * 2 * 3).
 * @see {@link external:THREE.BufferGeometry}
 * @see &lt;img src="/cwdc/13-webgl/examples/images/cube.png">
 */
function makeCube(create_indices = false) {
  // 8 vertices of cube
  // prettier-ignore
  const rawVertices = new Float32Array([
    -0.5, -0.5,  0.5,  // v0
     0.5, -0.5,  0.5,  // v1
     0.5,  0.5,  0.5,  // v2
    -0.5,  0.5,  0.5,  // v3
    -0.5, -0.5, -0.5,  // v4
     0.5, -0.5, -0.5,  // v5
     0.5,  0.5, -0.5,  // v6
    -0.5,  0.5, -0.5,  // v7
  ]);

  // prettier-ignore
  const rawColors = new Float32Array([
      1.0, 0.0, 0.0, 1.0,  // red
      0.0, 1.0, 0.0, 1.0,  // green
      0.0, 0.0, 1.0, 1.0,  // blue
      1.0, 1.0, 0.0, 1.0,  // yellow
      1.0, 0.0, 1.0, 1.0,  // magenta
      0.0, 1.0, 1.0, 1.0,  // cyan
    ]);

  // 6 normals of the faces
  // prettier-ignore
  const rawNormals = new Float32Array([
     0,  0,  1,  // +z face
     1,  0,  0,  // +x face
     0,  0, -1,  // -z face
    -1,  0,  0,  // -x face
     0,  1,  0,  // +y face
     0, -1,  0,  // -y face
  ]);

  // 8 texture coordinates of the vertices
  // prettier-ignore
  const rawTexture = new Float32Array([
    0.0, 0.0,  // v0
    1.0, 0.0,  // v1
    1.0, 1.0,  // v2
    0.0, 1.0,  // v3
    0.0, 0.0,  // v4
    1.0, 0.0,  // v5
    1.0, 1.0,  // v6
    0.0, 1.0,  // v7
 ]);

  const n = 1 / Math.sqrt(3);
  // 8 normals of the vertices
  // prettier-ignore
  const rawVertexNormals = new Float32Array([
    -n, -n,  n,  // v0
     n, -n,  n,  // v1
     n,  n,  n,  // v2
    -n,  n,  n,  // v3
    -n, -n, -n,  // v4
     n, -n, -n,  // v5
     n,  n, -n,  // v6
    -n,  n, -n,  // v7
 ]);

  // prettier-ignore
  const indices = new Uint16Array([
      0, 1, 2, 0, 2, 3,  // +z face
      2, 1, 5, 6, 2, 5,  // +x face
      5, 4, 7, 5, 7, 6,  // -z face
      7, 4, 0, 0, 3, 7,  // -x face
      3, 2, 7, 2, 6, 7,  // +y face
      0, 5, 1, 0, 4, 5   // -y face
    ]);

  const verticesArray = [];
  const colorsArray = [];
  const normalsArray = [];
  const textureArray = [];
  for (let i = 0; i &lt; 36; ++i) {
    // for each of the 36 vertices...
    let face = Math.floor(i / 6);
    let index = indices[i];

    // (x, y, z): three numbers for each point
    for (let j = 0; j &lt; 3; ++j) {
      verticesArray.push(rawVertices[3 * index + j]);
    }

    // (r, g, b, a): four numbers for each point
    for (let j = 0; j &lt; 4; ++j) {
      colorsArray.push(rawColors[4 * face + j]);
    }

    // (nx, ny, nz): three numbers for each point
    for (let j = 0; j &lt; 3; ++j) {
      normalsArray.push(rawNormals[3 * face + j]);
    }

    // (tx, ty): two numbers for each point
    for (let j = 0; j &lt; 2; ++j) {
      textureArray.push(rawTexture[2 * index + j]);
    }
  }

  return create_indices
    ? {
        numVertices: 8,
        vertices: rawVertices, // 24 = 8 * 3
        normals: rawVertexNormals, // 24 = 8 * 3
        texCoords: rawTexture, // 72 = 36 * 2
        indices: indices, // 36 = 6 faces * 2 tri/face  * 3 ind/tri
      }
    : {
        numVertices: 36, // 12 tri  * 3 vert/tri
        vertices: new Float32Array(verticesArray), // 108 = 36 * 3
        normals: new Float32Array(normalsArray), // 108 = 36 * 3
        colors: new Float32Array(colorsArray), // 144 = 36 * 4
        texCoords: new Float32Array(textureArray), // 72 = 36 * 2
        indices: new Uint16Array([...Array(36).keys()]), // 36 = 6 * 2 * 3
      };
}

/**
 * &lt;p>Matrix for taking normals into eye space.&lt;/p>
 * Returns a matrix to transform normals, so they stay
 * perpendicular to surfaces after a linear transformation.
 * @param {Matrix4} model model matrix.
 * @param {Matrix4} view view matrix.
 * @return {Float32Array} 3x3 normal matrix (transpose inverse) from the 4x4 modelview matrix.
 * @see &lt;a href="/cwdc/13-webgl/extras/doc/gdc12_lengyel.pdf#page=48">𝑛′=(𝑀&lt;sup>&amp;#8211;1&lt;/sup>)&lt;sup>𝑇&lt;/sup>⋅𝑛&lt;/a>
 */
function makeNormalMatrixElements(model, view) {
  var n = new Matrix4(view).multiply(model);
  n.transpose();
  n.invert();
  n = n.elements;
  // prettier-ignore
  return new Float32Array([
        n[0], n[1], n[2],
        n[4], n[5], n[6],
        n[8], n[9], n[10],
    ]);
}

/**
 * Translate keypress events to strings.
 * @param {KeyboardEvent} event key pressed.
 * @return {String} typed character.
 * @see https://javascript.info/tutorial/keyboard-events
 */
function getChar(event) {
  event = event || window.event;
  let charCode = event.key || String.fromCharCode(event.which);
  return charCode;
}

/**
 * &lt;p>Closure for keydown events.&lt;/p>
 * Chooses a {@link theModel model} and which {@link axis} to rotate around.&lt;br>
 * @param {KeyboardEvent} event keyboard event.
 * @function
 * @return {key_event} callback for handling a keyboard event.
 */
const handleKeyPress = ((event) => {
  let zoomfactor = 0.7;
  let gscale = 1;
  let models = document.getElementById("models");

  /**
   * &lt;p>Handler for keydown events.&lt;/p>
   * @param {KeyboardEvent} event keyboard event.
   * @callback key_event callback to handle a key pressed.
   */
  return (event) => {
    let ch = getChar(event);
    switch (ch) {
      case " ":
        selector.paused = !selector.paused;
        animate();
        break;
      case "x":
      case "y":
      case "z":
        axis = ch;
        break;
      case "o":
        modelMatrix.setIdentity();
        rotator.setViewMatrix(modelMatrix.elements);
        mscale = gscale;
        axis = "x";
        break;
      case "l":
        selector.lines = !selector.lines;
        if (!selector.lines) selector.texture = true;
        break;
      case "k":
        selector.texture = !selector.texture;
        if (!selector.texture) selector.lines = true;
        break;
      case "a":
        selector.axes = !selector.axes;
        break;
      case "v":
        // cube
        gscale = mscale = 1;
        models.value = "2";
        theModel = createModel(makeCube());
        //theModel = createModel(getModelData(new THREE.BoxGeometry(1, 1, 1)));
        break;
      case "s":
        // sphere with more faces
        gscale = mscale = 1;
        models.value = "5";
        theModel = createModel(
          getModelData(new THREE.SphereGeometry(1, 48, 24)),
        );
        break;
      case "T":
        // torus knot
        gscale = mscale = 1;
        models.value = "8";
        theModel = createModel(
          getModelData(new THREE.TorusKnotGeometry(0.6, 0.24, 128, 16)),
        );
        break;
      case "d":
        // dodecahedron
        gscale = mscale = 1;
        models.value = "9";
        theModel = createModel(
          getModelData(new THREE.DodecahedronGeometry(1, 0)),
        );
        break;
      case "p":
        // teapot - this is NOT a manifold model - it is a model with borders!
        gscale = mscale = 0.8;
        models.value = "6";
        theModel = createModel(
          getModelData(new TeapotGeometry(1, 10, true, true, true, true, true)),
          null,
        );
        break;
      case "ArrowUp":
      case ">":
        // Up pressed
        mscale *= zoomfactor;
        mscale = Math.max(gscale * 0.1, mscale);
        break;
      case "ArrowDown":
      case "&lt;":
        // Down pressed
        mscale /= zoomfactor;
        mscale = Math.min(gscale * 3, mscale);
        break;

      default:
        return;
    }
    if (selector.paused) draw();
  };
})();

/**
 * Returns a new keyboard event.
 * @param {String} key char code.
 * @returns {KeyboardEvent} a keyboard event.
 * @function
 */
var createEvent = (key) => {
  let code = key.charCodeAt();
  return new KeyboardEvent("keydown", {
    key: key,
    which: code,
    charCode: code,
    keyCode: code,
  });
};

/**
 * Selects a model from a menu.
 */
function selectModel() {
  let val = document.getElementById("models").value;
  let key = {
    2: "v", // cube
    5: "s", // sphere
    6: "p", // teapot
    8: "T", // knot
    9: "d", // dodecahedron
  };
  handleKeyPress(createEvent(key[val]));
}

window.selectModel = selectModel;

/**
 * &lt;p>Code to actually render our geometry.&lt;/p>
 * Draw {@link drawAxes axes}, {@link drawModel model}, and {@link drawLines lines}.
 */
function draw() {
  // clear the framebuffer
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  if (selector.axes) drawAxes();
  if (selector.texture) drawModel();
  if (selector.lines) drawLines();
}

/**
 * Returns a new scale model matrix, which applies mscale.
 * @returns {Matrix4} model matrix.
 */
function getModelMatrix() {
  var m = modelMatrix;
  if (mscale != 1) {
    m = new Matrix4(modelMatrix).scale(mscale, mscale, mscale);
  }
  return m;
}

/**
 * &lt;p>Draws the model, by
 * using the {@link lightingShader}.&lt;/p>
 * If {@link theModel}.indices is defined, then calls
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements drawElements}.
 * Otherwise, {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawArrays drawArrays}.
 * &lt;p>Since three.js {@link https://sbcode.net/threejs/geometry-to-buffergeometry/ version 125},
 * THREE.Geometry was deprecated and replaced by
 * {@link external:THREE.BufferGeometry THREE.BufferGeometry},
 * which always define indices for efficiency.
 */
function drawModel() {
  // bind the shader
  gl.useProgram(lightingShader);

  // get the index for the a_Position attribute defined in the vertex shader
  var positionIndex = gl.getAttribLocation(lightingShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var normalIndex = gl.getAttribLocation(lightingShader, "a_Normal");
  if (normalIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Normal");
    return;
  }

  // "enable" the a_position attribute
  gl.enableVertexAttribArray(positionIndex);
  gl.enableVertexAttribArray(normalIndex);

  // bind buffers for points
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
  gl.vertexAttribPointer(normalIndex, 3, gl.FLOAT, false, 0, 0);

  // set uniform in shader for projection * view * model transformation
  var loc = gl.getUniformLocation(lightingShader, "model");
  gl.uniformMatrix4fv(loc, false, getModelMatrix().elements);
  loc = gl.getUniformLocation(lightingShader, "view");
  gl.uniformMatrix4fv(loc, false, viewMatrix.elements);
  loc = gl.getUniformLocation(lightingShader, "projection");
  gl.uniformMatrix4fv(loc, false, projection.elements);
  loc = gl.getUniformLocation(lightingShader, "normalMatrix");
  gl.uniformMatrix3fv(
    loc,
    false,
    makeNormalMatrixElements(modelMatrix, viewMatrix),
  );

  loc = gl.getUniformLocation(lightingShader, "lightPosition");
  gl.uniform4f(loc, 2.0, 4.0, 2.0, 1.0);

  gl.uniform4f(
    gl.getUniformLocation(lightingShader, "diffuseColor"),
    0.0,
    0.8,
    0.8,
    1.0,
  );

  if (theModel.indices) {
    gl.drawElements(
      gl.TRIANGLES,
      theModel.indices.length,
      theModel.indices.constructor === Uint32Array
        ? gl.UNSIGNED_INT
        : gl.UNSIGNED_SHORT,
      0,
    );
  } else {
    gl.drawArrays(gl.TRIANGLES, 0, theModel.vertices.length / 3);
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.disableVertexAttribArray(positionIndex);
  gl.disableVertexAttribArray(normalIndex);
  gl.useProgram(null);
}

/**
 * &lt;p>Draws the axes. &lt;/p>
 * Uses the colorShader.
 */
function drawAxes() {
  // bind the shader
  gl.useProgram(colorShader);

  // get the index for the a_Position attribute defined in the vertex shader
  var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var colorIndex = gl.getAttribLocation(colorShader, "a_Color");
  if (colorIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Color");
    return;
  }

  // "enable" the a_position attribute
  gl.enableVertexAttribArray(positionIndex);
  gl.enableVertexAttribArray(colorIndex);

  // draw axes (not transformed by model transformation)
  gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ARRAY_BUFFER, axisColorBuffer);
  gl.vertexAttribPointer(colorIndex, 4, gl.FLOAT, false, 0, 0);

  // set transformation to projection * view only
  var loc = gl.getUniformLocation(colorShader, "transform");
  var transform = new Matrix4().multiply(projection).multiply(viewMatrix);
  gl.uniformMatrix4fv(loc, false, transform.elements);

  // draw axes
  gl.drawArrays(gl.LINES, 0, 6);

  // unbind shader and "disable" the attribute indices
  // (not really necessary when there is only one shader)
  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.disableVertexAttribArray(positionIndex);
  gl.disableVertexAttribArray(colorIndex);
  gl.useProgram(null);
}

/**
 * &lt;p>Draws the mesh edges and normals. &lt;/p>
 * Uses the colorShader.
 */
function drawLines() {
  // bind the shader
  gl.useProgram(colorShader);
  var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
  if (positionIndex &lt; 0) {
    console.log("Failed to get the storage location of a_Position");
    return;
  }

  var a_color = gl.getAttribLocation(colorShader, "a_Color");
  if (a_color &lt; 0) {
    console.log("Failed to get the storage location of a_Color");
    return;
  }
  gl.vertexAttrib4f(a_color, 1.0, 1.0, 0.0, 1.0);

  // "enable" the a_position attribute
  gl.enableVertexAttribArray(positionIndex);
  //  ------------ draw triangle borders
  // set transformation to projection * view * model
  var loc = gl.getUniformLocation(colorShader, "transform");
  var transform = new Matrix4()
    .multiply(projection)
    .multiply(viewMatrix)
    .multiply(getModelMatrix());
  gl.uniformMatrix4fv(loc, false, transform.elements);

  // draw edges
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  // takes too long on mobile
  /*
    for (var i = 0; i &lt; theModel.indices.length; i += 3) {
        // offset - two bytes per index (UNSIGNED_SHORT)
        gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i * 2);
    }
    */

  // draw edges
  if (theModel.indices) {
    gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
    gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.LINES, 0, 2 * theModel.indices.length);
  } else {
    for (var i = 0; i &lt; theModel.vertices.length; i += 3) {
      gl.drawArrays(gl.LINE_LOOP, i, 3);
    }
  }

  // draw normals
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.LINES, 0, 2 * theModel.vertices.length);

  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  gl.disableVertexAttribArray(positionIndex);
  gl.useProgram(null);
}

/**
 * &lt;p>Sets up all buffers for the given (triangulated) model (shape).&lt;/p>
 *
 * Uses the webgl vertex buffer, normal buffer, texture buffer and index buffer, created in {@link mainEntrance}.&lt;br>
 * Then, binds each one of them as an array buffer and copies the corresponding shape array data to them.
 *
 * &lt;p>Also, the Euler characteristic for the model is:&lt;/p>
 * &lt;ul>
 *  &lt;li>χ = 2 − 2g − b &lt;/li>
 * &lt;/ul>
 * for a surface with g handles and b boundaries.
 *
 * &lt;p>The number of triangles must be even for a valid triangulation of the sphere:&lt;/p>
 * &lt;ul>
 *  &lt;li> V - E + T = 2 (sphere) &lt;/li>
 *  &lt;li> V - E + T = 0 (torus) &lt;/li>
 * &lt;/ul>
 *
 * @param {modelData} shape a &lt;a href="https://en.wikipedia.org/wiki/Boundary_representation">BREP&lt;/a> model
 *                    given as an &lt;a href="https://math.hws.edu/graphicsbook/c3/s4.html">IFS&lt;/a>.
 * @param {Number | null} chi model &lt;a href="https://en.wikipedia.org/wiki/Euler_characteristic">Euler Characteristic&lt;/a>.
 * @returns {modelData} shape.
 * @see {@link https://en.wikipedia.org/wiki/Platonic_solid Platonic solid}
 * @see {@link https://ocw.mit.edu/courses/18-965-geometry-of-manifolds-fall-2004/pages/lecture-notes/ Geometry Of Manifolds}
 * @see {@link https://nrich.maths.org/1384 Euler's Formula and Topology}
 * @see {@link https://math.stackexchange.com/questions/3571483/euler-characteristic-of-a-polygon-with-a-hole Euler characteristic of a polygon with a hole}
 */
function createModel(shape, chi = 2) {
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, shape.vertices, gl.STATIC_DRAW);

  if (shape.indices) {
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, shape.normals, gl.STATIC_DRAW);

  let nv = shape.vertices.length;
  normal = new Float32Array(6 * nv);
  for (var i = 0, k = 0; i &lt; nv; i += 3, k += 6) {
    for (var j = 0; j &lt; 3; j++) {
      normal[j + k] = shape.vertices[i + j];
      normal[j + k + 3] = normal[j + k] + (0.1 / mscale) * shape.normals[i + j];
    }
  }

  // number of faces: ni / 3
  // number of edges: ni
  // number of endpoints: ni * 6
  if (shape.indices) {
    let ni = shape.indices.length;
    lines = new Float32Array(18 * ni);
    for (i = 0, k = 0; i &lt; ni; i += 3, k += 18) {
      for (j = 0; j &lt; 3; j++) {
        let v1 = shape.vertices[shape.indices[i] * 3 + j];
        let v2 = shape.vertices[shape.indices[i + 1] * 3 + j];
        let v3 = shape.vertices[shape.indices[i + 2] * 3 + j];

        lines[j + k] = v1;
        lines[j + k + 3] = v2;

        lines[j + k + 6] = v2;
        lines[j + k + 9] = v3;

        lines[j + k + 12] = v3;
        lines[j + k + 15] = v1;
      }
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, lines, gl.STATIC_DRAW);
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, normal, gl.STATIC_DRAW);

  let obj = document.getElementById("object");
  obj.innerHTML = "&lt;b>Object:&lt;/b>";
  let faces = shape.indices
    ? shape.indices.length / 3
    : shape.vertices.length / 9;
  let edges = (faces * 3) / 2;
  let vertices = faces / 2 + chi;

  if (chi === null) {
    edges = `${edges}??`;
    vertices = `${vertices}??`;
  }
  obj.innerHTML = `&lt;b>Object &lt;/b>(${faces} triangles, ${edges} edges, ${vertices} vertices):`;

  return shape;
}

/**
 * &lt;p>Entry point when page is loaded.&lt;/p>
 * Load all data into the buffers (just once) before proceeding.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData
 */
function mainEntrance() {
  // retrieve &lt;canvas> element
  var canvas = document.getElementById("theCanvas");

  /**
   * &lt;p>Key handler.&lt;/p>
   * Calls {@link handleKeyPress} whenever any of these keys is pressed:
   * &lt;ul>
   *  &lt;li>Space&lt;/li>
   *  &lt;li>x, y, z&lt;/li>
   *  &lt;li>p, s, T, o&lt;/li>
   *  &lt;li>a, k, l&lt;/li>
   * &lt;/ul>
   *
   * @event keydown
   */
  addEventListener("keydown", (event) => {
    if (
      ["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(
        event.code,
      ) > -1
    ) {
      event.preventDefault();
    }
    handleKeyPress();
  });

  // get the rendering context for WebGL
  gl = canvas.getContext("webgl2");
  if (!gl) {
    console.log("Failed to get the rendering context for WebGL");
    return;
  }

  // load and compile the shader pair, using utility from the teal book
  var vshaderSource = document.getElementById("vertexColorShader").textContent;
  var fshaderSource = document.getElementById(
    "fragmentColorShader",
  ).textContent;
  if (!initShaders(gl, vshaderSource, fshaderSource)) {
    console.log("Failed to initialize shaders.");
    return;
  }
  colorShader = gl.program;
  gl.useProgram(null);

  // load and compile the shader pair, using utility from the teal book
  var vshaderSource = document.getElementById(
    "vertexLightingShader",
  ).textContent;
  var fshaderSource = document.getElementById(
    "fragmentLightingShader",
  ).textContent;
  if (!initShaders(gl, vshaderSource, fshaderSource)) {
    console.log("Failed to initialize shaders.");
    return;
  }
  lightingShader = gl.program;
  gl.useProgram(null);

  // buffer for vertex positions for triangles
  vertexBuffer = gl.createBuffer();
  indexBuffer = gl.createBuffer();
  if (!vertexBuffer) {
    console.log("Failed to create the buffer object");
    return;
  }

  // buffer for vertex normals
  vertexNormalBuffer = gl.createBuffer();
  if (!vertexNormalBuffer) {
    console.log("Failed to create the buffer object");
    return;
  }

  // axes
  axisBuffer = gl.createBuffer();
  normalBuffer = gl.createBuffer();
  lineBuffer = gl.createBuffer();
  if (!axisBuffer) {
    console.log("Failed to create the buffer object");
    return;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, axisVertices, gl.STATIC_DRAW);

  // buffer for axis colors
  axisColorBuffer = gl.createBuffer();
  if (!axisColorBuffer) {
    console.log("Failed to create the buffer object");
    return;
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, axisColorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, axisColors, gl.STATIC_DRAW);

  gl.bindBuffer(gl.ARRAY_BUFFER, null);

  // specify a fill color for clearing the framebuffer
  gl.clearColor(0.0, 0.2, 0.2, 1.0);

  gl.enable(gl.DEPTH_TEST);

  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);

  rotator = new SimpleRotator(canvas, animate);
  rotator.setViewMatrix(modelMatrix.elements);
  rotator.setViewDistance(0);

  // initial model
  selectModel();

  // start drawing!
  animate();
}

/**
 * A closure to define an animation loop.
 * @return {loop}
 * @function
 */
var animate = (() => {
  // increase the rotation by some amount, depending on the axis chosen
  var increment = 0.5;
  /** @type {Number} */
  var requestID = 0;
  const axes = {
    x: [1, 0, 0],
    y: [0, 1, 0],
    z: [0, 0, 1],
  };

  /**
   * Callback to keep drawing frames.
   * @callback loop
   * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
   */
  return () => {
    draw();
    if (requestID != 0) {
      cancelAnimationFrame(requestID);
      requestID = 0;
    }
    if (!selector.paused) {
      modelMatrix = new Matrix4()
        .setRotate(increment, ...axes[axis])
        .multiply(modelMatrix);
      rotator.setViewMatrix(modelMatrix.elements);
      // request that the browser calls animate() again "as soon as it can"
      requestID = requestAnimationFrame(animate);
    } else {
      modelMatrix.elements = rotator.getViewMatrix();
    }
  };
})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-THREE.html">THREE</a></li></ul><h3>Classes</h3><ul><li><a href="Matrix4.html">Matrix4</a></li><li><a href="SimpleRotator.html">SimpleRotator</a></li><li><a href="TeapotGeometry.html">TeapotGeometry</a></li><li><a href="Vector3.html">Vector3</a></li><li><a href="Vector4.html">Vector4</a></li><li><a href="external-THREE.BufferGeometry.html">BufferGeometry</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:click">click</a></li><li><a href="global.html#event:keydown">keydown</a></li><li><a href="global.html#event:load">load</a></li></ul><h3>Global</h3><ul><li><a href="global.html#animate">animate</a></li><li><a href="global.html#axis">axis</a></li><li><a href="global.html#axisBuffer">axisBuffer</a></li><li><a href="global.html#axisColorBuffer">axisColorBuffer</a></li><li><a href="global.html#axisColors">axisColors</a></li><li><a href="global.html#axisVertices">axisVertices</a></li><li><a href="global.html#colorShader">colorShader</a></li><li><a href="global.html#createEvent">createEvent</a></li><li><a href="global.html#createModel">createModel</a></li><li><a href="global.html#createProgram">createProgram</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawAxes">drawAxes</a></li><li><a href="global.html#drawLines">drawLines</a></li><li><a href="global.html#drawModel">drawModel</a></li><li><a href="global.html#eye">eye</a></li><li><a href="global.html#getChar">getChar</a></li><li><a href="global.html#getModelData">getModelData</a></li><li><a href="global.html#getModelMatrix">getModelMatrix</a></li><li><a href="global.html#getWebGLContext">getWebGLContext</a></li><li><a href="global.html#gl">gl</a></li><li><a href="global.html#handleKeyPress">handleKeyPress</a></li><li><a href="global.html#indexBuffer">indexBuffer</a></li><li><a href="global.html#initShaders">initShaders</a></li><li><a href="global.html#lightingShader">lightingShader</a></li><li><a href="global.html#lineBuffer">lineBuffer</a></li><li><a href="global.html#lines">lines</a></li><li><a href="global.html#loadShader">loadShader</a></li><li><a href="global.html#mainEntrance">mainEntrance</a></li><li><a href="global.html#makeCube">makeCube</a></li><li><a href="global.html#makeNormalMatrixElements">makeNormalMatrixElements</a></li><li><a href="global.html#modelMatrix">modelMatrix</a></li><li><a href="global.html#mscale">mscale</a></li><li><a href="global.html#normal">normal</a></li><li><a href="global.html#normalBuffer">normalBuffer</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#rotator">rotator</a></li><li><a href="global.html#selectModel">selectModel</a></li><li><a href="global.html#selector">selector</a></li><li><a href="global.html#theModel">theModel</a></li><li><a href="global.html#vecLen">vecLen</a></li><li><a href="global.html#vertexBuffer">vertexBuffer</a></li><li><a href="global.html#vertexNormalBuffer">vertexNormalBuffer</a></li><li><a href="global.html#viewDistance">viewDistance</a></li><li><a href="global.html#viewMatrix">viewMatrix</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Mon Apr 22 2024 08:36:12 GMT-0300 (Brasilia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
