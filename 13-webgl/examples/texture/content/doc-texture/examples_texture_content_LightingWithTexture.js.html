<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: examples/texture/content/LightingWithTexture.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: examples/texture/content/LightingWithTexture.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 *
 * Summary.
 * &lt;p>Lighting combined with a procedural texture.&lt;/p>
 *
 * Same as &lt;a href="/cwdc/13-webgl/examples/lighting/content/doc-lighting2">Lighting2.js&lt;/a> except we define
 * a 3x3 matrix for &lt;a href="https://learnopengl.com/Lighting/Materials">material properties&lt;/a>
 * and a 3x3 matrix for {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL light properties}
 * that are passed to the fragment shader as &lt;a href="https://www.khronos.org/opengl/wiki/Uniform_(GLSL)">uniforms&lt;/a>.&lt;br>
 * Instead of sampling from an image, we use the texture coordinates to compute a color value out
 * of thin air.
 *
 * &lt;p>The procedural texture in the &lt;a href="/cwdc/13-webgl/examples/texture/content/showCode.php?f=LightingWithProceduralTexture">fragment shader&lt;/a>
 * covers the sphere with blue and golden stripes, which is very simple indeed:&lt;/p>
 * &lt;ol>
 *   &lt;li> multiply the "t" texture coordinate by the number of stripes of a given color (say 10),&lt;br>
 *        so the coordinates will be in the range [0.0, 10.0].
 *   &lt;li> consider that 0.0 to 0.5 is blue, 0.5 to 1.0 is yellow, 1.0 to 1.5 is blue, 1.5 to 2.0 is yellow, and so on...
 *   &lt;li> take the fractional part of the scaled "t" coordinate
 *        and test if it is less or greater than 0.5
 * &lt;/ol>
 *
 * &lt;p>One can edit the light/material matrices in the global variables to experiment,
 * or edit {@link startForReal} to choose a model and select
 * {@link https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/shading-normals face or vertex normals}.&lt;/p>
 *
 * @author Steve Kautz modified by Paulo Roma
 * @since 26/09/2016
 * @see &lt;a href="/cwdc/13-webgl/examples/texture/content/LightingWithProceduralTexture.html">Procedural texture&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/texture/content/LightingWithTexture.html">Image texture&lt;/a>
 * @see &lt;a href="/cwdc/13-webgl/examples/texture/content/LightingWithTexture.js">source&lt;/a>
 * @see &lt;img src="../striped-sphere.png" width="512">
 */

"use strict";

const mat4 = glMatrix.mat4;
const mat3 = glMatrix.mat3;

/**
 * Texture array.
 * @type {Array&lt;String>}
 */
var imageFilename = [
    "/cwdc/13-webgl/examples/images/check64.png",
    "/cwdc/13-webgl/examples/images/check64border.png",
    "/cwdc/13-webgl/examples/images/clover.jpg",
    "/cwdc/13-webgl/examples/images/brick.png",
    "/cwdc/13-webgl/examples/images/steve.png",
];

/**
 * Axes coordinates.
 * @type {Float32Array}
 */
//prettier-ignore
var axisVertices = new Float32Array([
    0.0, 0.0, 0.0,
    1.5, 0.0, 0.0,
    0.0, 0.0, 0.0,
    0.0, 1.5, 0.0,
    0.0, 0.0, 0.0,
    0.0, 0.0, 1.5,
]);

/**
 * Axes colors.
 * @type {Float32Array}
 */
//prettier-ignore
var axisColors = new Float32Array([
    1.0, 0.0, 0.0, 1.0,
    1.0, 0.0, 0.0, 1.0,
    0.0, 1.0, 0.0, 1.0,
    0.0, 1.0, 0.0, 1.0,
    0.0, 0.0, 1.0, 1.0,
    0.0, 0.0, 1.0, 1.0,
]);

// A few global variables...

// Light and material properties, remember this is column major.

/**
 * Generic white light.
 * @type {Float32Array}
 */
var lightPropElements = new Float32Array([
    0.2, 0.2, 0.2, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7,
]);

/**
 * Shiny brass.
 * @type {Float32Array}
 */
var matPropElements = new Float32Array([
    0.33, 0.22, 0.03, 0.78, 0.57, 0.11, 0.99, 0.91, 0.81,
]);

/**
 * @type {Number}
 */
var shininess = 28.0;

/* ---------------------------------------------------------------------
/**
 * Blue light with red specular highlights (because we can).
 * @type {Float32Array}
 *
var lightPropElements = new Float32Array([
    0.2, 0.2, 0.2, 0.0, 0.0, 0.7, 0.7, 0.0, 0.0,
]);

/**
 * Shiny green plastic.
 * @type {Float32Array}
 *
var matPropElements = new Float32Array([
    0.3, 0.3, 0.3, 0.0, 0.8, 0.0, 0.8, 0.8, 0.8,
]);
var shininess = 30;

/**
 * Very fake looking white, useful for testing lights.
 * @type {Float32Array}
 *
var matPropElements = new Float32Array([1, 1, 1, 1, 1, 1, 1, 1, 1]);
var shininess = 20.0;

/**
 * &lt;p>Clay or terracotta.&lt;/p>
 * Weak specular highlight similar to diffuse color.
 * @type {Float32Array}
 *
var matPropElements = new Float32Array([
    0.75, 0.38, 0.26, 0.75, 0.38, 0.26, 0.25, 0.2, 0.15,
]);
var shininess = 10.0;
--------------------------------------------------------------------- */

/**
 * The OpenGL context.
 * @type {WebGLRenderingContext}
 */
var gl;

/**
 * Our model data.
 * @type {modelData}
 */
var theModel;

/**
 * Array with normal end points.
 * @type {Float32Array}
 */
var normal;

/**
 * Array with edges end points.
 * @type {Float32Array}
 */
var lines;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var vertexBuffer;

/**  @type {WebGLBuffer} */
var indexBuffer;
/**  @type {WebGLBuffer} */
var vertexNormalBuffer;
/**  @type {WebGLBuffer} */
var texCoordBuffer;
/**  @type {WebGLBuffer} */
var axisBuffer;
/**  @type {WebGLBuffer} */
var axisColorBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var normalBuffer;

/**
 * Handle to a buffer on the GPU.
 * @type {WebGLBuffer}
 */
var lineBuffer;

/**
 * Handle to the texture object on the GPU.
 * @type {WebGLTexture}
 */
var textureHandle;

/**
 * Handle to the compiled shader program on the GPU.
 * @type {WebGLShader}
 */
var lightingShader;

/**
 * Handle to the compiled shader program on the GPU.
 * @type {WebGLShader}
 */
var colorShader;

/**
 * Model transformation matrix.
 * @Type {mat4}
 */
var modelMatrix = mat4.create();

/**
 * Current rotation axis.
 * @type {String}
 */
var axis = "x";

/**
 * Scale applied to a model to make its size adequate for rendering.
 * @type {Number}
 */
var mscale = 1;

/**
 * Turn the display of the model mesh/texture/axes/animation on/off.
 * @type {OBject&lt;{lines:Boolean, texture:Boolean, axes:Boolean, paused: Boolean, intrinsic: Boolean}>}
 */
var selector = {
    lines: document.getElementById("mesh").checked,
    texture: document.getElementById("texture").checked,
    axes: document.getElementById("axes").checked,
    paused: document.getElementById("pause").checked,
    intrinsic: true,
};

/**
 * Arcball.
 * @type {SimpleRotator}
 */
var rotator;

/**
 * Camera position.
 * @type {Array&lt;Number>}
 */
var eye = [1.77, 3.54, 3.06];

/**
 * View matrix.
 * @type {mat4}
 */
// prettier-ignore
const vMatrix = mat4.lookAt(
  [],
  eye,        // eye
  [0, 0, 0],  // at - looking at the origin
  [0, 1, 0]   // up vector - y axis
);

/**
 * View matrix.
 * @type {mat4}
 * @see &lt;a href="/cwdc/downloads/apostila.pdf#page=109">View matrix&lt;/a>
 */
var viewMatrix = mat4.copy([], vMatrix);

/**
 * Projection matrix.
 * @type {mat4}
 */
var projection = mat4.perspectiveNO([], (30 * Math.PI) / 180, 1.5, 0.1, 1000);

/**
 * Returns the magnitude (length) of a vector.
 * @param {Array&lt;Number>} v n-D vector.
 * @returns {Number} vector length.
 * @see https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce
 */
var vecLen = (v) =>
    Math.sqrt(v.reduce((accumulator, value) => accumulator + value * value, 0));

/**
 * View distance.
 * @type {Number}
 */
var viewDistance = vecLen(eye);

/**
 * An object containing raw data for
 * vertices, normal vectors, texture coordinates, and indices.
 * &lt;p>Polyhedra nave no index.&lt;/p>
 * @typedef {Object&lt;{vertices: Float32Array,
 *                   normals: Float32Array,
 *                   texCoords: Float32Array,
 *                   indices: Uint16Array}>} modelData
 */

/**
 * Given an instance of
 * &lt;ul>
 * &lt;li>&lt;a href="https://threejs.org/build/three.js">THREE.BufferGeometry&lt;/a>&lt;/li>
 * &lt;/ul>
 * returns an object containing raw data for
 * vertices, normal vectors, texture coordinates, and indices.
 * &lt;p>Polyhedra nave no index.&lt;/p>
 * @param {THREE.BufferGeometry} geom THREE.BoxGeometry,&lt;br>
 *                                    THREE.CapsuleGeometry,&lt;br>
 *                                    THREE.ConeGeometry,&lt;br>
 *                                    THREE.CylinderGeometry,&lt;br>
 *                                    THREE.PlaneGeometry,&lt;br>
 *                                    THREE.RingGeometry,&lt;br>
 *                                    THREE.SphereGeometry,&lt;br>
 *                                    THREE.TorusGeometry,&lt;br>
 *                                    THREE.TorusKnotGeometry,&lt;br>
 *                                    THREE.DodecahedronGeometry,&lt;br>
 *                                    THREE.IcosahedronGeometry,&lt;br>
 *                                    THREE.OctahedronGeometry,&lt;br>
 *                                    THREE.TetrahedronGeometry.
 * @return {modelData}
 * @see &lt;a href="https://threejs.org/docs/#api/en/core/BufferGeometry">BufferGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/BoxGeometry">BoxGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/CapsuleGeometry">CapsuleGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/ConeGeometry">ConeGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/CylinderGeometry">CylinderGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/PlaneGeometry">PlaneGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/RingGeometry">RingGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/SphereGeometry">SphereGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/TorusGeometry">TorusGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/DodecahedronGeometry">DodecahedronGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/IcosahedronGeometry">IcosahedronGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/OctahedronGeometry">OctahedronGeometry&lt;/a>
 * @see &lt;a href="https://threejs.org/docs/#api/en/geometries/TetrahedronGeometry">TetrahedronGeometry&lt;/a>
 */
function getModelData(geom) {
    return {
        vertices: geom.getAttribute("position").array,
        normals: geom.getAttribute("normal").array,
        texCoords: geom.getAttribute("uv").array,
        indices: geom.index ? geom.index.array : null,
    };
}

/**
 * &lt;p>Matrix for taking normals into eye space.&lt;/p>
 * Returns a matrix to transform normals, so they stay
 * perpendicular to surfaces after a linear transformation.
 * @param {mat4} model model matrix.
 * @param {mat4} view view matrix.
 * @return {Float32Array} 3x3 normal matrix (transpose inverse) from the 4x4 modelview matrix.
 * @see &lt;a href="/cwdc/13-webgl/extras/doc/gdc12_lengyel.pdf#page=48">𝑛′=(𝑀&lt;sup>&amp;#8211;1&lt;/sup>)&lt;sup>𝑇&lt;/sup>⋅𝑛&lt;/a>
 */
function makeNormalMatrixElements(model, view) {
    var modelview = mat4.multiply([], view, model);
    return mat3.normalFromMat4([], modelview);
}

/**
 * Translate keydown events to strings.
 * @param {KeyboardEvent} event keyboard event.
 * @return {String} typed character.
 * @see https://javascript.info/tutorial/keyboard-events
 */
function getChar(event) {
    event = event || window.event;
    let charCode = event.key || String.fromCharCode(event.which);
    return charCode;
}

/**
 * Handler for keydown events for choosing
 * which axis to rotate around, select model, etc.
 * @param {KeyboardEvent} event keyboard event.
 */
function handleKeyPress(event) {
    var ch = getChar(event);
    var d;
    switch (ch) {
        case " ":
            selector.paused = !selector.paused;
            document.getElementById("pause").checked = selector.paused;
            if (!selector.paused) document.getElementById(axis).checked = true;
            animate();
            return;
        case "x":
        case "y":
        case "z":
            axis = ch;
            selector.paused = false;
            document.getElementById(axis).checked = true;
            animate();
            return;
        case "O":
            mat4.identity(modelMatrix);
            mat4.copy(viewMatrix, vMatrix);
            if (selector.intrinsic) {
                rotator.setViewMatrix(viewMatrix);
                rotator.setViewDistance(viewDistance);
            } else {
                rotator.setViewMatrix(modelMatrix);
                rotator.setViewDistance(0);
            }
            break;
        case "C":
            mscale = 1;
            document.getElementById("models").value = "1";
            theModel = createModel(
                getModelData(new THREE.ConeGeometry(0.8, 1.5, 48, 24))
            );
            break;
        case "c":
            mscale = 1;
            document.getElementById("models").value = "3";
            theModel = createModel(
                getModelData(new THREE.CylinderGeometry(0.5, 0.5, 1.5, 24, 5))
            );
            break;
        case "r":
            mscale = 1;
            document.getElementById("models").value = "4";
            theModel = createModel(
                getModelData(
                    new THREE.RingGeometry(
                        0.3,
                        1.0,
                        30,
                        30,
                        0,
                        6.283185307179586
                    )
                ),
                0
            );
            break;
        case "u":
            mscale = 1;
            document.getElementById("models").value = "0";
            theModel = createModel(
                getModelData(new THREE.CapsuleGeometry(0.5, 0.5, 10, 20))
            );
            break;
        case "v":
            mscale = 1;
            document.getElementById("models").value = "2";
            theModel = createModel(
                getModelData(new THREE.BoxGeometry(1, 1, 1))
            );
            break;
        case "s":
            mscale = 1;
            document.getElementById("models").value = "5";
            theModel = createModel(
                getModelData(new THREE.SphereGeometry(1, 48, 24))
            );
            break;
        case "T":
            mscale = 1;
            document.getElementById("models").value = "8";
            theModel = createModel(
                getModelData(new THREE.TorusKnotGeometry(0.6, 0.24, 128, 16))
            );
            break;
        case "t":
            mscale = 1;
            document.getElementById("models").value = "7";
            theModel = createModel(
                getModelData(new THREE.TorusGeometry(0.6, 0.24, 16, 128)),
                0
            );
            break;
        case "d":
            mscale = 1;
            document.getElementById("models").value = "9";
            theModel = createModel(
                getModelData(new THREE.DodecahedronGeometry(1, 0))
            );
            break;
        case "i":
            mscale = 1;
            document.getElementById("models").value = "10";
            theModel = createModel(
                getModelData(new THREE.IcosahedronGeometry(1, 0))
            );
            break;
        case "o":
            mscale = 1;
            document.getElementById("models").value = "11";
            theModel = createModel(
                getModelData(new THREE.OctahedronGeometry(1, 0))
            );
            break;
        case "e":
        case "E":
            selector.intrinsic = !selector.intrinsic;
            document.getElementById("e").checked = !selector.intrinsic;
            document.getElementById("E").checked = selector.intrinsic;
            if (selector.intrinsic) {
                rotator.setViewMatrix(viewMatrix);
                rotator.setViewDistance(viewDistance);
            } else {
                mat4.targetTo(modelMatrix, eye, [0, 0, 0], [0, 1, 0]);
                rotator.setViewMatrix(modelMatrix);
                rotator.setViewDistance(0);
                mat4.copy(viewMatrix, vMatrix);
            }
            draw();
            return;
        case "w":
            mscale = 1;
            document.getElementById("models").value = "12";
            theModel = createModel(
                getModelData(new THREE.TetrahedronGeometry(1, 0))
            );
            break;
        case "p":
            mscale = 0.1;
            document.getElementById("models").value = "6";
            theModel = createModel(
                {
                    vertices: teapotModel.vertexPositions,
                    normals: teapotModel.vertexNormals,
                    texCoords: teapotModel.vertexTextureCoords,
                    indices: teapotModel.indices,
                },
                null
            );
            break;
        case "l":
            selector.lines = !selector.lines;
            if (!selector.lines) selector.texture = true;
            document.getElementById("mesh").checked = selector.lines;
            document.getElementById("texture").checked = selector.texture;
            break;
        case "k":
            selector.texture = !selector.texture;
            if (!selector.texture) selector.lines = true;
            document.getElementById("texture").checked = selector.texture;
            document.getElementById("mesh").checked = selector.lines;
            break;
        case "a":
            selector.axes = !selector.axes;
            document.getElementById("axes").checked = selector.axes;
            break;
        case "ArrowUp":
            // Up pressed
            if (selector.intrinsic) {
                d = rotator.getViewDistance();
                d = Math.min(d + 0.1, 10);
                rotator.setViewDistance(d);
            }
            break;
        case "ArrowDown":
            // Down pressed
            if (selector.intrinsic) {
                d = rotator.getViewDistance();
                d = Math.max(d - 0.1, 3);
                rotator.setViewDistance(d);
            }
            break;
        default:
            return;
    }
    if (selector.paused) draw();
}

/**
 * Returns a new keyboard event.
 * @param {String} key char code.
 * @returns {KeyboardEvent} a keyboard event.
 * @function
 */
var createEvent = (key) => {
    let code = key.charCodeAt();
    return new KeyboardEvent("keydown", {
        key: key,
        which: code,
        charCode: code,
        keyCode: code,
    });
};

/**
 * Selects a model from a menu.
 */
function selectModel() {
    let val = document.getElementById("models").value;
    let key = {
        0: "u", // capsule
        1: "C", // cone
        2: "v", // cube
        3: "c", // cylinder
        4: "r", // ring
        5: "s", // sphere
        6: "p", // teapot
        7: "t", // torus
        8: "T", // knot
        9: "d", // dodecahedron
        10: "i", // icosahedron
        11: "o", // octahedron
        12: "w", // tetrahedron
    };
    handleKeyPress(createEvent(key[val]));
}

const mesh = document.getElementById("mesh");
mesh.addEventListener("change", (event) => handleKeyPress(createEvent("l")));

const texture = document.getElementById("texture");
texture.addEventListener("change", (event) => handleKeyPress(createEvent("k")));

const axes = document.getElementById("axes");
axes.addEventListener("change", (event) => handleKeyPress(createEvent("a")));

if (document.querySelector('input[name="rot"]')) {
    document.querySelectorAll('input[name="rot"]').forEach((elem) => {
        elem.addEventListener("change", function (event) {
            var item = event.target.value;
            handleKeyPress(createEvent(item));
        });
    });
}

if (document.querySelector('input[name="euler"]')) {
    document.querySelectorAll('input[name="euler"]').forEach((elem) => {
        elem.addEventListener("change", function (event) {
            var item = event.target.value;
            handleKeyPress(createEvent(item));
        });
    });
}

window.addEventListener("load", (event) => mainEntrance());

/**
 *  &lt;p>Code to actually render our geometry.&lt;/p>
 * Draw {@link drawAxes axes}, {@link drawTexture texture}, and {@link drawLines lines}.
 */
function draw() {
    // clear the framebuffer
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    if (theModel === undefined) return;

    // the test here, instead in animate, allows using arcball
    // during automatic rotation
    if (!selector.intrinsic) {
        mat4.copy(modelMatrix, rotator.getViewMatrix());
    } else {
        mat4.copy(viewMatrix, rotator.getViewMatrix());
    }

    if (selector.axes) drawAxes();
    if (selector.texture) drawTexture();
    if (selector.lines) drawLines();
}

/**
 * Returns a new scale model matrix, which applies mscale.
 * @returns {mat4} model matrix.
 */
function getModelMatrix() {
    var m = modelMatrix;
    if (mscale != 1) {
        m = mat4.multiply(
            [],
            modelMatrix,
            mat4.fromScaling([], [mscale, mscale, mscale])
        );
    }
    return m;
}

/**
 * &lt;p>Texture render the current model.&lt;/p>
 * Uses the lightingShader.
 *
 * &lt;p>If the attribute "a_TexCoord" is not defined in the vertex shader,
 * texture coordinates will be calculated pixel by pixel
 * in the fragment shader.&lt;/p>
 */
function drawTexture() {
    // bind the shader
    gl.useProgram(lightingShader);

    // get the index for the a_Position attribute defined in the vertex shader
    var positionIndex = gl.getAttribLocation(lightingShader, "a_Position");
    if (positionIndex &lt; 0) {
        console.log("Failed to get the storage location of a_Position");
        return;
    }

    var normalIndex = gl.getAttribLocation(lightingShader, "a_Normal");
    if (normalIndex &lt; 0) {
        console.log("Failed to get the storage location of a_Normal");
        return;
    }

    var texCoordIndex = gl.getAttribLocation(lightingShader, "a_TexCoord");
    if (texCoordIndex &lt; 0) {
        console.log("Failed to get the storage location of a_TexCoord");
        return;
    }

    // "enable" the a_position attribute
    gl.enableVertexAttribArray(positionIndex);
    gl.enableVertexAttribArray(normalIndex);
    gl.enableVertexAttribArray(texCoordIndex);

    // bind buffers for points
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
    gl.vertexAttribPointer(normalIndex, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.vertexAttribPointer(texCoordIndex, 2, gl.FLOAT, false, 0, 0);
    //gl.bindBuffer(gl.ARRAY_BUFFER, null); &lt;---

    // set uniform in shader for projection * view * model transformation
    var loc = gl.getUniformLocation(lightingShader, "model");
    gl.uniformMatrix4fv(loc, false, getModelMatrix());
    loc = gl.getUniformLocation(lightingShader, "view");
    gl.uniformMatrix4fv(loc, false, viewMatrix);
    loc = gl.getUniformLocation(lightingShader, "projection");
    gl.uniformMatrix4fv(loc, false, projection);
    loc = gl.getUniformLocation(lightingShader, "normalMatrix");
    gl.uniformMatrix3fv(
        loc,
        false,
        makeNormalMatrixElements(modelMatrix, viewMatrix)
    );

    loc = gl.getUniformLocation(lightingShader, "lightPosition");
    gl.uniform4f(loc, 2.0, 4.0, 2.0, 1.0);

    // light and material properties
    loc = gl.getUniformLocation(lightingShader, "lightProperties");
    gl.uniformMatrix3fv(loc, false, lightPropElements);
    loc = gl.getUniformLocation(lightingShader, "materialProperties");
    gl.uniformMatrix3fv(loc, false, matPropElements);
    loc = gl.getUniformLocation(lightingShader, "shininess");
    gl.uniform1f(loc, shininess);

    // need to choose a texture unit, then bind the texture to TEXTURE_2D for that unit
    var textureUnit = 1;
    gl.activeTexture(gl.TEXTURE0 + textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, textureHandle);
    loc = gl.getUniformLocation(lightingShader, "sampler");
    gl.uniform1i(loc, textureUnit);

    if (theModel.indices) {
        gl.drawElements(
            gl.TRIANGLES,
            theModel.indices.length,
            gl.UNSIGNED_SHORT,
            0
        );
    } else {
        gl.drawArrays(gl.TRIANGLES, 0, theModel.vertices.length / 3);
    }

    gl.disableVertexAttribArray(positionIndex);
    gl.disableVertexAttribArray(normalIndex);
}

/**
 * &lt;p>Draws the axes. &lt;/p>
 * Uses the colorShader.
 */
function drawAxes() {
    // bind the shader
    gl.useProgram(colorShader);

    // get the index for the a_Position attribute defined in the vertex shader
    var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
    if (positionIndex &lt; 0) {
        console.log("Failed to get the storage location of a_Position");
        return;
    }

    var colorIndex = gl.getAttribLocation(colorShader, "a_Color");
    if (colorIndex &lt; 0) {
        console.log("Failed to get the storage location of a_Color");
        return;
    }

    // "enable" the a_position attribute
    gl.enableVertexAttribArray(positionIndex);
    gl.enableVertexAttribArray(colorIndex);

    // draw axes
    gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
    gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, axisColorBuffer);
    gl.vertexAttribPointer(colorIndex, 4, gl.FLOAT, false, 0, 0);
    //gl.bindBuffer(gl.ARRAY_BUFFER, null); &lt;----

    // set transformation to projection * view * model for intrinsic
    // or only projection * view for extrinsic
    var loc = gl.getUniformLocation(colorShader, "transform");
    var transform = mat4.multiply([], projection, viewMatrix);
    if (selector.intrinsic) {
        mat4.multiply(transform, transform, modelMatrix);
    }

    gl.uniformMatrix4fv(loc, false, transform);

    // draw axes
    gl.drawArrays(gl.LINES, 0, 6);

    // unbind shader and "disable" the attribute indices
    // (not really necessary when there is only one shader)
    gl.disableVertexAttribArray(positionIndex);
    gl.disableVertexAttribArray(colorIndex);
    gl.useProgram(null);
}

/**
 * &lt;p>Draws the mesh edges and normals. &lt;/p>
 * Uses the colorShader.
 */
function drawLines() {
    // bind the shader
    gl.useProgram(colorShader);
    var positionIndex = gl.getAttribLocation(colorShader, "a_Position");
    if (positionIndex &lt; 0) {
        console.log("Failed to get the storage location of a_Position");
        return;
    }

    var a_color = gl.getAttribLocation(colorShader, "a_Color");
    if (a_color &lt; 0) {
        console.log("Failed to get the storage location of a_Color");
        return;
    }
    gl.vertexAttrib4f(a_color, 1.0, 1.0, 0.0, 1.0);

    // "enable" the a_position attribute
    gl.enableVertexAttribArray(positionIndex);
    //  ------------ draw triangle borders
    // set transformation to projection * view * model
    var loc = gl.getUniformLocation(colorShader, "transform");
    var transform = mat4.multiply(
        [],
        projection,
        mat4.multiply([], viewMatrix, getModelMatrix())
    );
    gl.uniformMatrix4fv(loc, false, transform);

    // draw edges
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    // takes too long on mobile
    /*
    for (var i = 0; i &lt; theModel.indices.length; i += 3) {
        // offset - two bytes per index (UNSIGNED_SHORT)
        gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i * 2);
    }
    */

    // draw edges
    if (theModel.indices) {
        gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
        gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.LINES, 0, 2 * theModel.indices.length);
    } else {
        for (var i = 0; i &lt; theModel.vertices.length; i += 3) {
            gl.drawArrays(gl.LINE_LOOP, i, 3);
        }
    }

    // draw normals
    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.vertexAttribPointer(positionIndex, 3, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.LINES, 0, 2 * theModel.vertices.length);

    gl.disableVertexAttribArray(positionIndex);
    gl.useProgram(null);
}

/**
 * Entry point when page is loaded.
 * Wait for image to load before proceeding.
 */
function mainEntrance() {
    var image = new Image();
    image.onload = function () {
        // chain the next function
        startForReal(image);
    };

    // starts loading the image asynchronously
    image.src = imageFilename[1];
}

/**
 * &lt;p>Entry point when page is loaded.&lt;/p>
 * Basically this function does setup that "should" only have to be done once,
 * while {@link draw} does things that have to be repeated each time the canvas is
 * redrawn.
 * @param {HTMLImageElement} image texture image.
 */
function startForReal(image) {
    // retrieve &lt;canvas> element
    var canvas = document.getElementById("theCanvas");

    // key handler
    window.addEventListener("keydown", (event) => {
        if (
            [
                "Space",
                "ArrowUp",
                "ArrowDown",
                "ArrowLeft",
                "ArrowRight",
            ].indexOf(event.code) > -1
        ) {
            event.preventDefault();
        }
        handleKeyPress(event);
    });

    // get the rendering context for WebGL
    gl = canvas.getContext("webgl");
    if (!gl) {
        console.log("Failed to get the rendering context for WebGL");
        return;
    }

    // load and compile the shader pair, using utility from the teal book
    var vshaderSource =
        document.getElementById("vertexColorShader").textContent;
    var fshaderSource = document.getElementById(
        "fragmentColorShader"
    ).textContent;
    if (!initShaders(gl, vshaderSource, fshaderSource)) {
        console.log("Failed to initialize shaders.");
        return;
    }
    colorShader = gl.program;
    gl.useProgram(null);

    // load and compile the shader pair, using utility from the teal book
    var vshaderSource = document.getElementById(
        "vertexLightingShader"
    ).textContent;
    var fshaderSource = document.getElementById(
        "fragmentLightingShader"
    ).textContent;
    if (!initShaders(gl, vshaderSource, fshaderSource)) {
        console.log("Failed to initialize shaders.");
        return;
    }
    lightingShader = gl.program;
    gl.useProgram(null);

    // buffer for vertex positions for triangles
    vertexBuffer = gl.createBuffer();
    indexBuffer = gl.createBuffer();
    if (!vertexBuffer) {
        console.log("Failed to create the buffer object");
        return;
    }

    // buffer for vertex normals
    vertexNormalBuffer = gl.createBuffer();
    if (!vertexNormalBuffer) {
        console.log("Failed to create the buffer object");
        return;
    }

    // buffer for tex coords
    texCoordBuffer = gl.createBuffer();
    if (!texCoordBuffer) {
        console.log("Failed to create the buffer object");
        return;
    }

    // ask the GPU to create a texture object
    textureHandle = gl.createTexture();

    // choose a texture unit to use during setup, defaults to zero
    // (can use a different one when drawing)
    // max value is MAX_COMBINED_TEXTURE_IMAGE_UNITS
    gl.activeTexture(gl.TEXTURE0);

    // bind the texture
    gl.bindTexture(gl.TEXTURE_2D, textureHandle);

    // load the image bytes to the currently bound texture, flipping the vertical
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

    // texture parameters are stored with the texture
    gl.generateMipmap(gl.TEXTURE_2D);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);  // default is REPEAT

    // axes
    axisBuffer = gl.createBuffer();
    normalBuffer = gl.createBuffer();
    lineBuffer = gl.createBuffer();
    if (!axisBuffer) {
        console.log("Failed to create the buffer object");
        return;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, axisBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, axisVertices, gl.STATIC_DRAW);

    // buffer for axis colors
    axisColorBuffer = gl.createBuffer();
    if (!axisColorBuffer) {
        console.log("Failed to create the buffer object");
        return;
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, axisColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, axisColors, gl.STATIC_DRAW);

    //gl.bindBuffer(gl.ARRAY_BUFFER, null); &lt;----

    // specify a fill color for clearing the framebuffer
    gl.clearColor(0.0, 0.4, 0.4, 1.0);

    gl.enable(gl.DEPTH_TEST);

    rotator = new SimpleRotator(canvas, draw);
    handleKeyPress(createEvent("O"));

    selectModel();

    // start drawing!
    animate();
}

/**
 * &lt;p>Sets up all buffers for the given model (shape).&lt;/p>
 *
 * Uses the webgl vertex buffer, normal buffer, texture buffer and index buffer, created in {@link startForReal}.&lt;br>
 * Then, binds each one of them as an array buffer and copies the corresponding shape array data to them.
 *
 * &lt;p>Also, the Euler characteristic for the model is:&lt;/p>
 * &lt;ul>
 *  &lt;li>χ = 2 − 2g − b &lt;/li>
 * &lt;/ul>
 * for a surface with g handles and b boundaries.
 *
 * &lt;p>The number of triangles must be even for a valid triangulation of the sphere:&lt;/p>
 * &lt;ul>
 *  &lt;li> V - E + T = 2 (sphere) &lt;/li>
 *  &lt;li> V - E + T = 0 (torus) &lt;/li>
 * &lt;/ul>
 *
 *
 * @param {modelData} shape a &lt;a href="https://en.wikipedia.org/wiki/Boundary_representation">BREP&lt;/a> model
 *                    given as an &lt;a href="https://math.hws.edu/graphicsbook/c3/s4.html">IFS&lt;/a>.
 * @param {Number | null} chi model &lt;a href="https://en.wikipedia.org/wiki/Euler_characteristic">Euler Characteristic&lt;/a>.
 * @returns {modelData} shape.
 * @see https://en.wikipedia.org/wiki/Platonic_solid
 * @see http://www-groups.mcs.st-andrews.ac.uk/~john/MT4521/Lectures/L25.html
 * @see https://nrich.maths.org/1384
 * @see https://math.stackexchange.com/questions/3571483/euler-characteristic-of-a-polygon-with-a-hole
 *
 */
function createModel(shape, chi = 2) {
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, shape.vertices, gl.STATIC_DRAW);

    if (shape.indices) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shape.indices, gl.STATIC_DRAW);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);

    gl.bufferData(gl.ARRAY_BUFFER, shape.normals, gl.STATIC_DRAW);

    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, shape.texCoords, gl.STATIC_DRAW);

    let nv = shape.vertices.length;
    normal = new Float32Array(6 * nv);
    for (var i = 0, k = 0; i &lt; nv; i += 3, k += 6) {
        for (var j = 0; j &lt; 3; j++) {
            normal[j + k] = shape.vertices[i + j];
            normal[j + k + 3] =
                normal[j + k] + (0.1 / mscale) * shape.normals[i + j];
        }
    }

    // number of faces: ni / 3
    // number of edges: ni
    // number of endpoints: ni * 6
    if (shape.indices) {
        let ni = shape.indices.length;
        lines = new Float32Array(18 * ni);
        for (i = 0, k = 0; i &lt; ni; i += 3, k += 18) {
            for (j = 0; j &lt; 3; j++) {
                let v1 = shape.vertices[shape.indices[i] * 3 + j];
                let v2 = shape.vertices[shape.indices[i + 1] * 3 + j];
                let v3 = shape.vertices[shape.indices[i + 2] * 3 + j];

                lines[j + k] = v1;
                lines[j + k + 3] = v2;

                lines[j + k + 6] = v2;
                lines[j + k + 9] = v3;

                lines[j + k + 12] = v3;
                lines[j + k + 15] = v1;
            }
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, lineBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, lines, gl.STATIC_DRAW);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, normal, gl.STATIC_DRAW);

    let obj = document.getElementById("object");
    obj.innerHTML = "&lt;b>Object:&lt;/b>";
    if (chi !== null) {
        let faces = shape.indices
            ? shape.indices.length / 3
            : shape.vertices.length / 9;
        let edges = (faces * 3) / 2;
        let vertices = faces / 2 + chi;
        obj.innerHTML = `&lt;b>Object &lt;/b>(${faces} triangles, ${edges} edges, ${vertices} vertices):`;
    }

    return shape;
}

/**
 * A closure to define an animation loop.
 * @return {frame}
 * @function
 * @see https://dominicplein.medium.com/extrinsic-intrinsic-rotation-do-i-multiply-from-right-or-left-357c38c1abfd
 */
var animate = (() => {
    // increase the rotation by some amount (30°/s), depending on the axis chosen
    const increment = (0.5 * Math.PI) / 180;
    /** @type {Number} */
    var requestID = 0;
    const axes = {
        x: [1, 0, 0],
        y: [0, 1, 0],
        z: [0, 0, 1],
    };

    /**
     * Callback to keep drawing frames.
     * @callback frame
     * @see https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelAnimationFrame
     */
    return () => {
        // to avoid speed up
        if (requestID != 0) {
            cancelAnimationFrame(requestID);
            requestID = 0;
        }
        if (!selector.paused) {
            let rotMatrix = mat4.fromRotation([], increment, axes[axis]);
            if (selector.intrinsic) {
                // intrinsic rotation (multiply on the right)
                mat4.multiply(modelMatrix, modelMatrix, rotMatrix);
            } else {
                // extrinsic rotation (multiply on the left)
                mat4.multiply(modelMatrix, rotMatrix, modelMatrix);
                rotator.setViewMatrix(modelMatrix);
            }
            draw();
            // request that the browser calls animate() again "as soon as it can"
            requestID = requestAnimationFrame(animate);
        }
    };
})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-glMatrix.html">glMatrix</a></li><li><a href="module-mat2.html">mat2</a></li><li><a href="module-mat2d.html">mat2d</a></li><li><a href="module-mat3.html">mat3</a></li><li><a href="module-mat4.html">mat4</a></li><li><a href="module-quat.html">quat</a></li><li><a href="module-quat2.html">quat2</a></li><li><a href="module-vec2.html">vec2</a></li><li><a href="module-vec3.html">vec3</a></li><li><a href="module-vec4.html">vec4</a></li></ul><h3>Classes</h3><ul><li><a href="SimpleRotator.html">SimpleRotator</a></li></ul><h3>Global</h3><ul><li><a href="global.html#animate">animate</a></li><li><a href="global.html#axis">axis</a></li><li><a href="global.html#axisBuffer">axisBuffer</a></li><li><a href="global.html#axisColorBuffer">axisColorBuffer</a></li><li><a href="global.html#axisColors">axisColors</a></li><li><a href="global.html#axisVertices">axisVertices</a></li><li><a href="global.html#colorShader">colorShader</a></li><li><a href="global.html#createEvent">createEvent</a></li><li><a href="global.html#createModel">createModel</a></li><li><a href="global.html#createProgram">createProgram</a></li><li><a href="global.html#draw">draw</a></li><li><a href="global.html#drawAxes">drawAxes</a></li><li><a href="global.html#drawLines">drawLines</a></li><li><a href="global.html#drawTexture">drawTexture</a></li><li><a href="global.html#eye">eye</a></li><li><a href="global.html#getChar">getChar</a></li><li><a href="global.html#getModelData">getModelData</a></li><li><a href="global.html#getModelMatrix">getModelMatrix</a></li><li><a href="global.html#getWebGLContext">getWebGLContext</a></li><li><a href="global.html#gl">gl</a></li><li><a href="global.html#handleKeyPress">handleKeyPress</a></li><li><a href="global.html#imageFilename">imageFilename</a></li><li><a href="global.html#indexBuffer">indexBuffer</a></li><li><a href="global.html#initShaders">initShaders</a></li><li><a href="global.html#lightPropElements">lightPropElements</a></li><li><a href="global.html#lightingShader">lightingShader</a></li><li><a href="global.html#lineBuffer">lineBuffer</a></li><li><a href="global.html#lines">lines</a></li><li><a href="global.html#loadShader">loadShader</a></li><li><a href="global.html#mainEntrance">mainEntrance</a></li><li><a href="global.html#makeNormalMatrixElements">makeNormalMatrixElements</a></li><li><a href="global.html#matPropElements">matPropElements</a></li><li><a href="global.html#modelMatrix">modelMatrix</a></li><li><a href="global.html#mscale">mscale</a></li><li><a href="global.html#normal">normal</a></li><li><a href="global.html#normalBuffer">normalBuffer</a></li><li><a href="global.html#projection">projection</a></li><li><a href="global.html#rotator">rotator</a></li><li><a href="global.html#selectModel">selectModel</a></li><li><a href="global.html#selector">selector</a></li><li><a href="global.html#shininess">shininess</a></li><li><a href="global.html#startForReal">startForReal</a></li><li><a href="global.html#teapotModel">teapotModel</a></li><li><a href="global.html#texCoordBuffer">texCoordBuffer</a></li><li><a href="global.html#textureHandle">textureHandle</a></li><li><a href="global.html#theModel">theModel</a></li><li><a href="global.html#vMatrix">vMatrix</a></li><li><a href="global.html#vecLen">vecLen</a></li><li><a href="global.html#vertexBuffer">vertexBuffer</a></li><li><a href="global.html#vertexNormalBuffer">vertexNormalBuffer</a></li><li><a href="global.html#viewDistance">viewDistance</a></li><li><a href="global.html#viewMatrix">viewMatrix</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sat Sep 02 2023 10:58:16 GMT-0300 (Brasilia Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
