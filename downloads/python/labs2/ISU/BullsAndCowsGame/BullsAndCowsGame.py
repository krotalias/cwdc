#!/usr/bin/env python
# coding: UTF-8
#
## @package BullsAndCowsGame
#
#  Bulls and Cows (also known as Cows and Bulls or Pigs and Bulls or Bulls and Cleots)
#  is an old code-breaking paper and pencil game for two players,
#  predating the similar commercially marketed board game Mastermind.
#
#  @author Paulo Roma
#  @since 12/07/2016
#  @see http://en.wikipedia.org/wiki/Bulls_and_cows
#  @see http://www.python-course.eu/sets_frozensets.php
#  @see https://www.dicio.com.br/palavras-com-cinco-letras/
#

import sys
import codecs
from enum import Enum
from random import randint, random, choice, shuffle

##
# Enumerated type representing possible status after
# guessing a word in the BullsAndCows game.
#
class Status(Enum):
    INVALID_WORD = 1
    LOSE_TURN = 2
    KEEP_TURN = 3
    WIN = 4
    OVER = 5

## A person (Host) thinks of any isogram word, and gives out the number of letters
# in the word (4 or 5 letters).
# Other players (Guessers) try to figure that word by guessing isogram words
# containing the same number of letters.
# Host responds with the number of Cows & Bulls for each guessed word. As with the digit version,
# "Cow" means a letter in the wrong position, while "Bull" means a letter in the right position.
#
# The object of the game is to guess a secret word. As an example, suppose we are playing
# with 5 letters and that the secret word is “aisle”.
# Initially the players see the following displayed:
#
#    "*****"
#
# The player must guess a 5-letter word. It must be a valid word (this will be verified using the
# WordList class). Suppose Player 0 starts and guesses “house”.
#
#    aisle
#
#    house
#
# Notice that the “e” in “house” occurs in the correct position in the secret word. This is called a
# bull. The letter “s” in “house” also occurs in the hidden word, but not in the correct position.
# This is called a cow. The letters h, o, and u aren’t in the secret word at all, so in keeping with the
# barnyard theme we will call them geese. The display then shows all the bulls in their correct
# positions:
#
#    ****e
#
#    Cows: s
#
#    Geese: hou
#
class BullsAndCowsGame:
    ##
    #  Character to use as a placeholder for the hidden
    #  characters when displaying the "bulls".
    #
    PLACEHOLDER = '*'

    ## Fills bulls string with the appropriate number of placeholders.
    #
    # @param size bulls length.
    #
    def initBulls(self, size):
        if size > 0:
            self.bulls = size * BullsAndCowsGame.PLACEHOLDER

    ## Counts the number of occurrences of a char in a string.
    #
    #  @param haystack a string.
    #  @param needle char to look for.
    #  @return number of occurrences.
    #
    def countOccurrencesOf(self, haystack, needle):
        return haystack.count(needle)

    ##  Constructs a new game, using the given WordList as a dictionary, that will use words of
    #  the specified size the game will start with the first word of the given size that is
    #  generated by the word list.
    #
    #  @param wlist dictionary.
    #  @param arg a word or a size.
    #
    def __init__(self, wlist, arg):
        ## Word dictionary.
        self.dict = wlist
        ## Current status of the game: over or on going.
        self.gameStatus = Status.KEEP_TURN
        ## Letters tried so far.
        self.guessedLetters = ""
        ## Letters found so far.
        self.bulls = ""

        #  Constructs a new game, using the given WordList as a dictionary, that will use the size of
        #  the given word for the word length the game will start with firstWord. (The purpose of
        #  this constructor is to simplify testing.)
        #  @param firstWord initial secret word.
        if isinstance(arg, str) or (sys.hexversion < 0x03000000 and isinstance(arg, unicode)):
            firstWord = arg.lower()
            if wlist.check(firstWord):
                ## The word to be guessed: given.
                self.secretWord = firstWord
                self.initBulls(len(firstWord))
            else:
                raise ValueError("Invalid word")
        else:
            if isinstance(arg, int):
                ## The word to be guessed: random.
                self.secretWord = wlist.generate(arg)
                self.initBulls(arg)
            else:  # unknown type
                print("Type of arg: %s" % type(arg))
                raise TypeError("Invalid type")

    ## Starts a new round of the game, using the next word generated by this game’s WordList.
    #
    #
    def startNewRound(self):
        self.guessedLetters = ""
        self.secretWord = self.dict.generate(len(self.secretWord))
        if self.secretWord != "":
            self.initBulls(len(self.secretWord))
        self.gameStatus = Status.KEEP_TURN

    ## Returns true if the current round is over (that is, there are no more hidden letters).
    #
    #  @return true whether the game is over, and false otherwise.
    #
    def isOver(self):
        return self.gameStatus == Status.WIN

    ## Returns the secret word for this round. The returned
    #  string is all lowercase.
    #
    #  @return secret word.
    #
    def getSecretWord(self):
        return self.secretWord

    ## Returns a string containing all letters of all guessed words in the current round, without
    #  duplicates, in the order they first occurred in the players’ guesses.
    #  The returned string is all lowercase.
    #
    def getAllGuessedLetters(self):
        return self.guessedLetters

    ## Returns the string with the bulls revealed in their positions and other letters replaced by
    #  PLACEHOLDER. All letters in the returned string are lowercase.
    #
    #  @return bulls.
    #
    def getBulls(self):
        return self.bulls

    ## Returns a string containing all guessed letters for the current round that do not occur in
    #  the secret word. The returned string is all lowercase, has no duplicates, and the order of
    #  the letters is the same as in getAllGuessedLetters().
    #
    #  @return guesses.
    #
    def getGeese(self):
        geese = ""

        for c in self.guessedLetters:
            if not c in self.secretWord:
                geese += c

        return geese

    ## Returns a string containing all guessed letters for the current round that do occur in the
    #  secret word but have an occurrence that is still hidden. The returned string is all
    #  lowercase, has no duplicates, and the order of the letters is the same as in
    #  getAllGuessedLetters().
    #
    #  @return cows.
    #
    def getCows(self):
        cows = ""

        for c in self.guessedLetters:
            nc = self.secretWord.count(c)
            # c does not occur in bulls as many times as it occurs in secretWord
            if self.bulls.count(c) < nc:
                cows += c

        return cows

    ## Processes a player’s guess and returns the appropriate status.
    #  This method is not case sensitive.
    #
    #  @param word a guess.
    #  @return game status.
    #
    def guess(self, word):
        word = word.lower()

        if self.isOver():
            return Status.OVER

        if len(self.secretWord) != len(word) or not self.dict.check(word):
            return Status.INVALID_WORD

        stat = Status.LOSE_TURN
        l = list(self.bulls)  # strings are immutable
        for i in range(0, len(word)):
            c = word[i]
            if self.secretWord[i] == c and self.bulls[i] == self.PLACEHOLDER:
                l[i] = c
                stat = Status.KEEP_TURN

            if not c in self.guessedLetters:
                self.guessedLetters += c

        self.bulls = ''.join(l)

        if self.bulls == self.secretWord:
            stat = self.gameStatus = Status.WIN

        return stat

##
# Class representing a dictionary of short words for
# word-guessing games.
#
class WordList:

    ##
    # Constructs a new WordList containing words from the given file.
    #
    # @param filename file of words, one per line.
    #
    def __init__(self, filename):
        ## Set of possible lengths in words.
        self.sizes = set()
        self.initialize(filename)

    ##
    # Returns a randomly selected word from this WordList if one
    # exists of the specified size.
    #
    # @param size length of the selected word.
    # @return
    #   a randomly selected word, or null if no word exists of
    #   the specified size
    #
    def generate(self, size):
        if not (size in self.sizes):
            return None

        word = ""
        while (len(word) != size):
            word = choice(self.words)
        return word

    ##
    # Determines whether the given word occurs in this word list.
    #
    # @param word
    #   the word to check
    # @return
    #   true if the word occurs in this word list or if the word
    #   list is empty
    #
    def check(self, word):
        if not self.words:
            return true

        # Use binary search. The list must be ordered...
        return self.binarySearch(self.words, word) >= 0
        # Or plain python search on lists.
        #return word in self.words

    ##
    # Initializes the WordList from a file of words.
    #
    # @param filename name of the file full of words, one per line.
    #
    def initialize(self, filename):
        # if there is no filename, do nothing
        if not filename:
            return None

        # First read the file, and store the lengths of the words found
        try:
            if (sys.hexversion > 0x03000000):
                f = open(filename, 'r')
            else:
                f = codecs.open(filename, 'r', "utf-8")
        except IOError as e:
            print("\nI/O error({0}): {1}".format(e.errno, e.strerror))
            sys.exit('Cannot open file %s for reading' % filename)

        tempList = []
        for word in f:
            # record the possible lengths of words in this list
            word = word.splitlines()[0]  # remove "\n"
            length = len(word)

            # using a set avoids checking the previous inclusion
            # if not(length in self.sizes):
            #   self.sizes.append(length)

            self.sizes.add(length)

            # add the word to the list
            tempList.append(word.lower())

        f.close()

        ## Lists of words of various lengths.
        self.words = tempList

    ##
    # Returns the index of a string in a sorted array,
    # or -1 if the string is not present.
    #
    # @param alist
    #   array of strings
    # @param word
    #   the string for which to search
    # @return
    #   index of the string, or -1 if it is not found
    #
    def binarySearch(self, alist, word):
        start = 0
        end = len(alist) - 1
        while start <= end:
            mid = (start + end) // 2
            if word == alist[mid]:
                return mid
            else:
                if word < alist[mid]:
                    end = mid - 1
                else:
                    start = mid + 1
        return -1

##
# A simple text-based user interface for the BullsAndCowsGame.
#
class TextUI:

    ## Class (static) variable.
    # Name of file containing words.
    #
    DICTIONARY_FILENAME = "words.txt"

    ## Class (static) variable.
   # Size of words to use for this game.
   #
    WORD_SIZE = 5

    ##
    # Constructs a user interface that will use the given game.
    #
    # @param givenGame a game object.
    #
    def __init__(self, givenGame):
        ## The game object used by this UI.
        self.game = givenGame

    ##
    # Main user interface loop.
    #
    def runUI(self):
        done = False

        # start with player 0
        whoseTurn = 0

        while not done:
            self.display()

            try:
                if (sys.hexversion > 0x03000000):
                    word = input("Player %d enter your guess: " % whoseTurn)
                else:
                    word = raw_input("Player %d enter your guess: " %
                                     whoseTurn).decode("utf-8")
            except KeyboardInterrupt:
                exit("\nTerminated by user %d" % whoseTurn)

            word = word.strip().lower()
            status = self.game.guess(word)
            if status == Status.INVALID_WORD:
                print("Invalid word!")
                whoseTurn = 1 - whoseTurn
                print("It is player %d's turn now." % whoseTurn)
            elif status == Status.LOSE_TURN:
                print("Sorry, no new bulls.")
                whoseTurn = 1 - whoseTurn
                print("It is player %s's turn now." % whoseTurn)
            elif status == Status.KEEP_TURN:
                print("Good guess!")
            elif status == Status.WIN:
                print("You won!")
                print("The word was " + self.game.getSecretWord())
                done = not self.playAgain()
                if not done:
                    self.game.startNewRound()
                    print("\nSecret Word = " + self.game.getSecretWord())
                    whoseTurn = 1 - whoseTurn

    ##
    # Displays the game state.
    #
    def display(self):
        print("")
        print("------------------------------")
        print("Bulls: " + self.game.getBulls())
        print("Cows:  " + self.game.getCows())
        print("Geese: " + self.game.getGeese())
        print("------------------------------")

    ##
    # Queries whether the player wants to play again.
    #
    # @return
    #   true if the player chooses to play again, false otherwise
    #
    def playAgain(self):
        try:
            if (sys.hexversion > 0x03000000):
                response = input("Do you want to play again (y/n)?")
            else:
                response = raw_input("Do you want to play again (y/n)?")
        except (SyntaxError, KeyboardInterrupt):
            exit("\nTerminated by user")
        return len(response) > 0 and response.lower()[0] == "y"

## Main program for testing.
#
# Usage: "BullsAndCowsGame.py palavras.txt ainda"
#
# @param argv secret word and word file name.
#
def main(argv=None):
    if argv is None:
        argv = sys.argv

    wlist = WordList(TextUI.DICTIONARY_FILENAME)
    if len(argv) > 1:  # a file name for getting words from was given
        print("Running: %s" % argv[0])
        TextUI.DICTIONARY_FILENAME = argv[1]
        wlist = WordList(TextUI.DICTIONARY_FILENAME)

        if len(argv) > 2:  # a secret word was also given
            if (sys.hexversion > 0x03000000):
                secretWord = argv[2]
            else:
                secretWord = argv[2].decode("utf-8")
            TextUI.WORD_SIZE = len(secretWord)
            print("secret word = %s, length = %d\n" %
                  (secretWord, TextUI.WORD_SIZE))
            game = main2(TextUI.DICTIONARY_FILENAME,
                         secretWord)  # a given secret word
        else:
            game = BullsAndCowsGame(wlist, TextUI.WORD_SIZE)
    else:
        game = BullsAndCowsGame(wlist, TextUI.WORD_SIZE)
    print("\nSecret Word = %s" % game.getSecretWord())
    ui = TextUI(game)
    ui.runUI()

## Another test.
#
#  @param fwords filename for getting words from.
#  @param word secret word.
#
def main2(fwords, word):
    wl = WordList(fwords)
    try:
        bcg = BullsAndCowsGame(wl, word)
    except (ValueError, TypeError) as detail:
        print(detail)
        exit('Searching word "%s" in file "%s"' %
             (word, TextUI.DICTIONARY_FILENAME))

    # just testing
    i = wl.binarySearch(wl.words, word)
    print("%s index: %d" % (word, i))
    print("words[%d] = %s" % (i, wl.words[i]))
    print("Dictionary sizes: %s" % wl.sizes)
    print("A word of size %d: %s" %
          (TextUI.WORD_SIZE, wl.generate(TextUI.WORD_SIZE)))

    return bcg


if __name__ == "__main__":
    sys.exit(main())
